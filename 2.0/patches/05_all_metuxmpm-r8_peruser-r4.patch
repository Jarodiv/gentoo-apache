diff -Nur httpd-2.0.52/server/mpm/config.m4 httpd-2.0.52-metux-peruser/server/mpm/config.m4
--- httpd-2.0.52/server/mpm/config.m4	2003-03-11 08:07:52.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/config.m4	2004-10-18 16:00:15.625171672 +0200
@@ -1,7 +1,7 @@
 AC_MSG_CHECKING(which MPM to use)
 AC_ARG_WITH(mpm,
 APACHE_HELP_STRING(--with-mpm=MPM,Choose the process model for Apache to use.
-                          MPM={beos|worker|prefork|mpmt_os2|perchild|leader|threadpool}),[
+                          MPM={beos|worker|prefork|mpmt_os2|perchild|leader|threadpool|metuxmpm|peruser}),[
   APACHE_MPM=$withval
 ],[
   if test "x$APACHE_MPM" = "x"; then
@@ -26,7 +26,7 @@
 APACHE_FAST_OUTPUT(server/mpm/Makefile)
 
 MPM_NAME=$apache_cv_mpm
-if test "$MPM_NAME" = "leader" -o "$MPM_NAME" = "threadpool" -o "$MPM_NAME" = "perchild"; then
+if test "$MPM_NAME" = "leader" -o "$MPM_NAME" = "threadpool" -o "$MPM_NAME" = "perchild" -o "$MPM_NAME" = "peruser" -o "$MPM_NAME" = "metuxmpm"; then
   AC_MSG_WARN(You have selected an EXPERIMENTAL MPM.  Be warned!)
   MPM_SUBDIR_NAME=experimental/$MPM_NAME
 else
diff -Nur httpd-2.0.52/server/mpm/experimental/metuxmpm/Makefile.in httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/Makefile.in
--- httpd-2.0.52/server/mpm/experimental/metuxmpm/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/Makefile.in	2004-10-18 15:58:44.153077544 +0200
@@ -0,0 +1,5 @@
+
+LTLIBRARY_NAME    = libmetuxmpm.la
+LTLIBRARY_SOURCES = metuxmpm.c
+
+include $(top_srcdir)/build/ltlib.mk
diff -Nur httpd-2.0.52/server/mpm/experimental/metuxmpm/config5.m4 httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/config5.m4
--- httpd-2.0.52/server/mpm/experimental/metuxmpm/config5.m4	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/config5.m4	2004-10-18 15:58:44.153077544 +0200
@@ -0,0 +1,6 @@
+dnl ## XXX - Need a more thorough check of the proper flags to use
+
+if test "$MPM_NAME" = "metuxmpm" ; then
+    AC_CHECK_FUNCS(pthread_kill) 
+    APACHE_FAST_OUTPUT(server/mpm/$MPM_SUBDIR_NAME/Makefile)
+fi
diff -Nur httpd-2.0.52/server/mpm/experimental/metuxmpm/metuxmpm.c httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/metuxmpm.c
--- httpd-2.0.52/server/mpm/experimental/metuxmpm/metuxmpm.c	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/metuxmpm.c	2004-10-18 15:58:44.168075264 +0200
@@ -0,0 +1,2594 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" must
+ *    not be used to endorse or promote products derived from this
+ *    software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    nor may "Apache" appear in their name, without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Portions of this software are based upon public domain software
+ * originally written at the National Center for Supercomputing Applications,
+ * University of Illinois, Urbana-Champaign.
+ */
+
+/* TODO:
+    + replace pipe_of_death by an generic command interface 
+    + also use this interface for child->child communications
+    + add support for runtime configuration over this if.
+    + what to do w/ unassigned vhosts ? who should handle them ?
+      perhaps we shoudda add an DefaultProcessor option ?
+    + test, test, test, and test, especially under high load.
+    + what about persistent links w/ changing vhost ?
+      should the client then give it back to the multiplexer ?
+    + add timeouts in multiplexer to prevent local dos attacks
+    + think about possible vulnarabilities. note that the vhost's user
+      could ptrace the processor child and play nice games with it.
+*/
+    
+/* -- build configuration -- manly for debugging -- */
+
+/* #define MPM_METUXMPM_DEBUG */
+
+#define MPM_THREAD_ACCEPT_LOCK
+
+#include "apr_hash.h"
+#include "apr_strings.h"
+#include "apr_pools.h"
+#include "apr_portable.h"
+#include "apr_file_io.h"
+#include "apr_signal.h"
+
+#define APR_WANT_IOVEC
+#include "apr_want.h"
+
+#if APR_HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if APR_HAVE_SYS_SOCKET_H
+#include <sys/socket.h>
+#endif
+
+#if !APR_HAS_THREADS
+#error The metuxmpm MPM requires APR threads, but they are unavailable.
+#endif  
+
+#define CORE_PRIVATE 
+ 
+#include "ap_config.h"
+#include "httpd.h" 
+#include "http_main.h" 
+#include "http_log.h" 
+#include "http_config.h"    /* for read_config */ 
+#include "http_core.h"      /* for get_remote_host */ 
+#include "http_protocol.h"
+#include "http_connection.h"
+#include "ap_mpm.h"
+#include "unixd.h"
+#include "mpm_common.h"
+#include "ap_listen.h"
+#include "mpm_default.h"
+#include "mpm.h"
+#include "scoreboard.h"
+#include "util_filter.h"
+#include "apr_poll.h"
+
+#include "util_ebcdic.h"
+
+#ifdef HAVE_POLL_H
+#include <poll.h>
+#endif
+#ifdef HAVE_SYS_POLL_H
+#include <sys/poll.h>
+#endif
+
+/* ### should be APR-ized */
+#include <grp.h>
+#include <pwd.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <setjmp.h>
+#ifdef HAVE_SYS_PROCESSOR_H
+#include <sys/processor.h> /* for bindprocessor() */
+#endif
+
+#ifdef MPM_METUXMPM_DEBUG
+# define _DBG(text,par...) \
+    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL, \
+		 "(metuxmpm: pid=%d uid=%d) %s(): " text, \
+		 getpid(), getuid(), __FUNCTION__, ##par, 0)
+
+# define _TRACE_CALL(text,par...) _DBG("calling " text, ##par)
+# define _TRACE_RET(text,par...) _DBG("returned from " text, ##par)
+#else
+# define _DBG(text,par...)
+# define _TRACE_RET(text,par...)
+# define _TRACE_CALL(text,par...)
+#endif /* MPM_METUXMPM_DEBUG */
+
+/* char of death - for signalling children to die */
+#define AP_metuxmpm_CHAR_OF_DEATH	'!'
+
+#define metuxmpm_SERVER_CONF(cf)	\
+    ((metuxmpm_server_conf *) ap_get_module_config(cf,&mpm_metuxmpm_module))
+
+
+/*
+ * Define some magic numbers that we use for the state of the incomming
+ * request. These must be < 0 so they don't collide with a file descriptor.
+ */
+#define AP_metuxmpm_THISCHILD -1
+#define AP_metuxmpm_OTHERCHILD -2
+
+/* Limit on the threads per process.  Clients will be locked out if more than
+ * this * server_limit are needed.
+ *
+ * We keep this for one reason it keeps the size of the scoreboard file small
+ * enough that we can read the whole thing without worrying too much about
+ * the overhead.
+ */
+#ifndef DEFAULT_THREAD_LIMIT
+#define DEFAULT_THREAD_LIMIT 64 
+#endif
+
+/* Admin can't tune ThreadLimit beyond MAX_THREAD_LIMIT.  We want
+ * some sort of compile-time limit to help catch typos.
+ */
+#ifndef MAX_THREAD_LIMIT
+#define MAX_THREAD_LIMIT 20000
+#endif 
+
+/* Limit on the total --- clients will be locked out if more servers than
+ * this are needed.  It is intended solely to keep the server from crashing
+ * when things get out of hand.
+ *
+ * We keep a hard maximum number of servers, for two reasons --- first off,
+ * in case something goes seriously wrong, we want to stop the fork bomb
+ * short of actually crashing the machine we're running on by filling some
+ * kernel table.  Secondly, it keeps the size of the scoreboard file small
+ * enough that we can read the whole thing without worrying too much about
+ * the overhead.
+ */
+#ifndef DEFAULT_SERVER_LIMIT
+#define DEFAULT_SERVER_LIMIT 256
+#endif
+
+/* Admin can't tune ServerLimit beyond MAX_SERVER_LIMIT.  We want
+ * some sort of compile-time limit to help catch typos.
+ */
+#ifndef MAX_SERVER_LIMIT
+#define MAX_SERVER_LIMIT 20000
+#endif
+
+/*
+ * Actual definitions of config globals
+ */
+
+static int threads_to_start = 0;         /* Worker threads per child */
+static int min_spare_threads = 0;
+static int max_spare_threads = 0;
+static int max_threads = 0;
+static int server_limit = DEFAULT_SERVER_LIMIT;
+static int first_server_limit;
+static int thread_limit = DEFAULT_THREAD_LIMIT;
+static int first_thread_limit;
+static int changed_limit_at_restart;
+static int num_childs = 0;
+static int workers_may_exit = 0;
+static int requests_this_child;
+static int num_listensocks = 0;
+static ap_pod_t *pod;
+static jmp_buf jmpbuffer;
+static int thread_overflow_reported = 0;
+
+/* === configuration stuff === */
+/* the server limit is also the size of the server table */
+static int cf_server_limit = DEFAULT_SERVER_LIMIT;
+
+/* -- server process information -- */
+typedef struct
+{
+    uid_t uid;
+    gid_t gid;
+    int input;       /* The socket descriptor */
+    int output;      /* The socket descriptor */
+    int type;
+    int id;	     /* index in child_info_table */
+    const char *chroot_dir; /* can be null */
+} child_info_t;
+
+#define CHILD_TYPE_MULTIPLEXER	1
+#define CHILD_TYPE_PROCESSOR	2
+
+typedef struct 
+{
+    const char *sockname;       /* The base name for the socket */
+    const char *fullsockname;   /* socket base name + extension */
+    child_info_t* child;	/* The client which processes this server */
+} metuxmpm_server_conf;
+
+typedef struct
+{
+    int sock_fd;
+    int status;
+    jmp_buf jmpbuffer;
+} thread_info_t;
+    
+/* Tables used to determine the user and group each child process should
+ * run as.  The hash table is used to correlate a server name with a child
+ * process.
+ */
+static int            child_info_table_size;
+static child_info_t  *child_info_table;
+static thread_info_t *thread_info_table;
+struct ap_ctable     *ap_child_table;
+
+/*
+ * The max child slot ever assigned, preserved across restarts.  Necessary
+ * to deal with NumServers changes across AP_SIG_GRACEFUL restarts.  We 
+ * use this value to optimize routines that have to scan the entire child 
+ * table.
+ *
+ * XXX - It might not be worth keeping this code in. There aren't very
+ * many child processes in this MPM.
+ */
+int ap_max_daemons_limit = -1;
+int ap_threads_per_child; /* XXX not part of API!  axe it! */
+
+module AP_MODULE_DECLARE_DATA mpm_metuxmpm_module;
+
+/* -- replace the pipe-of-death by an control socket -- */
+static apr_file_t *pipe_of_death_in = NULL;
+static apr_file_t *pipe_of_death_out = NULL;
+static apr_thread_mutex_t *pipe_of_death_mutex;
+
+/* *Non*-shared http_main globals... */
+
+server_rec *ap_server_conf;
+
+/* one_process --- debugging mode variable; can be set from the command line
+ * with the -X flag.  If set, this gets you the child_main loop running
+ * in the process which originally started up (no detach, no make_child),
+ * which is a pretty nice debugging environment.  (You'll get a SIGHUP
+ * early in standalone_main; just continue through.  This is the server
+ * trying to kill off any child processes which it might have lying
+ * around --- Apache doesn't keep track of their pids, it just sends
+ * SIGHUP to the process group, ignoring it in the root process.
+ * Continue through and you'll be fine.).
+ */
+
+static int one_process = 0;
+
+#ifdef DEBUG_SIGSTOP
+int raise_sigstop_flags;
+#endif
+
+static apr_pool_t *pconf;              /* Pool for config stuff */
+static apr_pool_t *pchild;             /* Pool for httpd child stuff */
+static apr_pool_t *thread_pool_parent; /* Parent of per-thread pools */
+static apr_thread_mutex_t *thread_pool_parent_mutex;
+
+static int child_num;
+static unsigned int my_pid; /* Linux getpid() doesn't work except in 
+                      main thread. Use this instead */
+
+/* -- stack w/ free thread slot IDs */
+static int *worker_thread_free_ids;
+static apr_threadattr_t *worker_thread_attr;
+
+/* Keep track of the number of idle worker threads */
+static int idle_thread_count;
+static apr_thread_mutex_t *idle_thread_count_mutex;
+
+/* Locks for accept serialization */
+#ifdef NO_SERIALIZED_ACCEPT
+
+#define ACCEPT_PROC_MUTEX_INIT		APR_SUCCESS
+#define ACCEPT_PROC_MUTEX_LOCK		APR_SUCCESS
+#define ACCEPT_PROC_MUTEX_UNLOCK	APR_SUCCESS
+#define ACCEPT_PROC_MUTEX_CREATE	APR_SUCCESS
+
+#else
+
+static apr_proc_mutex_t *process_accept_mutex;
+
+#define ACCEPT_PROC_MUTEX_LOCK 		(apr_proc_mutex_lock(process_accept_mutex))
+#define ACCEPT_PROC_MUTEX_UNLOCK	(apr_proc_mutex_unlock(process_accept_mutex))
+#define ACCEPT_PROC_MUTEX_CREATE	(apr_proc_mutex_create(&process_accept_mutex,ap_lock_fname, ap_accept_lock_mech,_pconf))
+#define	ACCEPT_PROC_MUTEX_INIT		(apr_proc_mutex_child_init(&process_accept_mutex, ap_lock_fname, pchild));
+
+#endif /* NO_SERIALIZED_ACCEPT */
+
+static apr_thread_mutex_t *thread_accept_mutex;
+
+#ifdef MPM_metuxmpm_THREAD_ACCEPT_LOCK
+
+#define THREAD_ACCEPT_LOCK					\
+	_DBG("locking thread_accept_mutex",0);			\
+	apr_thread_mutex_lock(thread_accept_mutex);		\
+	_DBG("got thread_accept_mutex locked",0);
+				    
+#define THREAD_ACCEPT_UNLOCK	 				\
+	_DBG("unlocking thread_accept_mutex",0);			\
+	apr_thread_mutex_unlock(thread_accept_mutex);		\
+	_DBG("got thread_accept_mutex unlocked",0);
+#else
+
+#define THREAD_ACCEPT_LOCK					\
+	_DBG("omitted locking thread_accept_mutex",0);
+	
+#define THREAD_ACCEPT_UNLOCK					\
+	_DBG("omitted unlocking thread_accept_mutex",0);
+
+#endif
+/* == Keep track of the number of worker threads currently active == */
+static int worker_thread_count = 0;
+static apr_thread_mutex_t *worker_thread_count_mutex;
+
+static inline int worker_thread_count_get ()
+{
+    int x;
+    apr_thread_mutex_lock(worker_thread_count_mutex);
+    x = worker_thread_count;
+    apr_thread_mutex_unlock(worker_thread_count_mutex);
+    _DBG("worker_thread_count=%d", x);
+    return x;
+}
+
+static inline int worker_thread_count_add ( int x )
+{
+    int y;
+    apr_thread_mutex_lock(worker_thread_count_mutex);
+    worker_thread_count += x;
+    y = worker_thread_count;
+    apr_thread_mutex_unlock(worker_thread_count_mutex);
+    _DBG("worker_thread_count=%d (+%d)", y, x);
+    return y;
+}        
+
+/* ------------------------------------------------------------------- */
+
+AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
+{
+    switch(query_code){
+        case AP_MPMQ_MAX_DAEMON_USED:
+            *result = ap_max_daemons_limit;
+            return APR_SUCCESS;
+        case AP_MPMQ_IS_THREADED:
+            *result = AP_MPMQ_DYNAMIC;
+            return APR_SUCCESS;
+        case AP_MPMQ_IS_FORKED:
+            *result = AP_MPMQ_STATIC;
+            return APR_SUCCESS;
+        case AP_MPMQ_HARD_LIMIT_DAEMONS:
+            *result = cf_server_limit;
+            return APR_SUCCESS;
+        case AP_MPMQ_HARD_LIMIT_THREADS:
+            *result = thread_limit;
+            return APR_SUCCESS;
+        case AP_MPMQ_MAX_THREADS:
+            *result = max_threads;
+            return APR_SUCCESS;
+        case AP_MPMQ_MIN_SPARE_DAEMONS:
+            *result = 0;
+            return APR_SUCCESS;
+        case AP_MPMQ_MIN_SPARE_THREADS:    
+            *result = min_spare_threads;
+            return APR_SUCCESS;
+        case AP_MPMQ_MAX_SPARE_DAEMONS:
+            *result = 0;
+            return APR_SUCCESS;
+        case AP_MPMQ_MAX_SPARE_THREADS:
+            *result = max_spare_threads;
+            return APR_SUCCESS;
+        case AP_MPMQ_MAX_REQUESTS_DAEMON:
+            *result = ap_max_requests_per_child;
+            return APR_SUCCESS; 
+        case AP_MPMQ_MAX_DAEMONS:
+            *result = num_childs;
+            return APR_SUCCESS;
+    }
+    return APR_ENOTIMPL;
+}
+
+/* a clean exit from a child with proper cleanup */
+static inline int clean_child_exit(int code)
+{
+    if (pchild) apr_pool_destroy(pchild);
+    exit(code);
+}
+
+/* handle all varieties of core dumping signals */
+static void sig_coredump(int sig)
+{
+    chdir(ap_coredump_dir);
+    apr_signal(sig, SIG_DFL);
+    kill(getpid(), sig);
+    /* At this point we've got sig blocked, because we're still inside
+     * the signal handler.  When we leave the signal handler it will
+     * be unblocked, and we'll take the signal... and coredump or whatever
+     * is appropriate for this particular Unix.  In addition the parent
+     * will see the real signal we received -- whereas if we called
+     * abort() here, the parent would only see SIGABRT.
+     */
+}
+
+static void just_die(int sig)
+{
+    clean_child_exit(0);
+}
+
+/*****************************************************************
+ * Connection structures and accounting...
+ */
+
+/* volatile just in case */
+static int volatile shutdown_pending;
+static int volatile restart_pending;
+static int volatile is_graceful;
+static int volatile child_fatal;
+/* we don't currently track ap_my_generation, but mod_status 
+ * references it so it must be defined */
+ap_generation_t volatile ap_my_generation=0;
+
+/*
+ * ap_start_shutdown() and ap_start_restart(), below, are a first stab at
+ * functions to initiate shutdown or restart without relying on signals. 
+ * Previously this was initiated in sig_term() and restart() signal handlers, 
+ * but we want to be able to start a shutdown/restart from other sources --
+ * e.g. on Win32, from the service manager. Now the service manager can
+ * call ap_start_shutdown() or ap_start_restart() as appropiate.  Note that
+ * these functions can also be called by the child processes, since global
+ * variables are no longer used to pass on the required action to the parent.
+ *
+ * These should only be called from the parent process itself, since the
+ * parent process will use the shutdown_pending and restart_pending variables
+ * to determine whether to shutdown or restart. The child process should
+ * call signal_parent() directly to tell the parent to die -- this will
+ * cause neither of those variable to be set, which the parent will
+ * assume means something serious is wrong (which it will be, for the
+ * child to force an exit) and so do an exit anyway.
+ */
+
+static void ap_start_shutdown(void)
+{
+    if (shutdown_pending == 1) 
+    {
+        /* Um, is this _probably_ not an error, if the user has
+         * tried to do a shutdown twice quickly, so we won't
+         * worry about reporting it.
+         */
+        return;
+    }
+    shutdown_pending = 1;
+}
+
+/* do a graceful restart if graceful == 1 */
+static void ap_start_restart(int graceful)
+{
+    if (restart_pending == 1) 
+    {
+        /* Probably not an error - don't bother reporting it */
+        return;
+    }
+    restart_pending = 1;
+    is_graceful = graceful;
+}
+
+static void sig_term(int sig)
+{
+    ap_start_shutdown();
+}
+
+static void restart(int sig)
+{
+    ap_start_restart(sig == AP_SIG_GRACEFUL);
+}
+
+static void set_signals(void)
+{
+#ifndef NO_USE_SIGACTION
+    struct sigaction sa;
+
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+
+    if (!one_process) {
+        sa.sa_handler = sig_coredump;
+#if defined(SA_ONESHOT)
+        sa.sa_flags = SA_ONESHOT;
+#elif defined(SA_RESETHAND)
+        sa.sa_flags = SA_RESETHAND;
+#endif
+        if (sigaction(SIGSEGV, &sa, NULL) < 0)
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                         "sigaction(SIGSEGV)");
+#ifdef SIGBUS
+        if (sigaction(SIGBUS, &sa, NULL) < 0)
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                         "sigaction(SIGBUS)");
+#endif
+#ifdef SIGABORT
+        if (sigaction(SIGABORT, &sa, NULL) < 0)
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                         "sigaction(SIGABORT)");
+#endif
+#ifdef SIGABRT
+        if (sigaction(SIGABRT, &sa, NULL) < 0)
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                         "sigaction(SIGABRT)");
+#endif
+#ifdef SIGILL
+        if (sigaction(SIGILL, &sa, NULL) < 0)
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                         "sigaction(SIGILL)");
+#endif
+        sa.sa_flags = 0;
+    }
+    sa.sa_handler = sig_term;
+    if (sigaction(SIGTERM, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                     "sigaction(SIGTERM)");
+#ifdef SIGINT
+    if (sigaction(SIGINT, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                     "sigaction(SIGINT)");
+#endif
+#ifdef SIGXCPU
+    sa.sa_handler = SIG_DFL;
+    if (sigaction(SIGXCPU, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                     "sigaction(SIGXCPU)");
+#endif
+#ifdef SIGXFSZ
+    sa.sa_handler = SIG_DFL;
+    if (sigaction(SIGXFSZ, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                     "sigaction(SIGXFSZ)");
+#endif
+#ifdef SIGPIPE
+    sa.sa_handler = SIG_IGN;
+    if (sigaction(SIGPIPE, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                     "sigaction(SIGPIPE)");
+#endif
+
+    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy 
+     * processing one */
+    sigaddset(&sa.sa_mask, SIGHUP);
+    sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
+    sa.sa_handler = restart;
+    if (sigaction(SIGHUP, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                     "sigaction(SIGHUP)");
+    if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                     "sigaction(" AP_SIG_GRACEFUL_STRING ")");
+#else
+    if (!one_process) 
+    {
+        apr_signal(SIGSEGV, sig_coredump);
+#ifdef SIGBUS
+        apr_signal(SIGBUS, sig_coredump);
+#endif /* SIGBUS */
+#ifdef SIGABORT
+        apr_signal(SIGABORT, sig_coredump);
+#endif /* SIGABORT */
+#ifdef SIGABRT
+        apr_signal(SIGABRT, sig_coredump);
+#endif /* SIGABRT */
+#ifdef SIGILL
+        apr_signal(SIGILL, sig_coredump);
+#endif /* SIGILL */
+#ifdef SIGXCPU
+        apr_signal(SIGXCPU, SIG_DFL);
+#endif /* SIGXCPU */
+#ifdef SIGXFSZ
+        apr_signal(SIGXFSZ, SIG_DFL);
+#endif /* SIGXFSZ */
+    }
+
+    apr_signal(SIGTERM, sig_term);
+#ifdef SIGHUP
+    apr_signal(SIGHUP, restart);
+#endif /* SIGHUP */
+#ifdef AP_SIG_GRACEFUL
+    apr_signal(AP_SIG_GRACEFUL, restart);
+#endif /* AP_SIG_GRACEFUL */
+#ifdef SIGPIPE
+    apr_signal(SIGPIPE, SIG_IGN);
+#endif /* SIGPIPE */
+
+#endif
+}
+
+/*****************************************************************
+ * Here follows a long bunch of generic server bookkeeping stuff...
+ */
+
+int ap_graceful_stop_signalled(void)
+{
+    /* XXX - Does this really work? - Manoj */
+    return is_graceful;
+}
+
+/*****************************************************************
+ * Child process main loop.
+ */
+
+static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id,
+                           apr_bucket_alloc_t *bucket_alloc)
+{
+    conn_rec *current_conn;
+    int sock_fd;
+    apr_status_t rv;
+    int thread_num = conn_id % thread_limit;
+    ap_sb_handle_t *sbh;
+
+    if ((rv = apr_os_sock_get(&sock_fd, sock)) != APR_SUCCESS) 
+    {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_os_sock_get");
+    }
+
+    _DBG("thread_num=%d sock=%ld sock_fd=%d\n", thread_num, sock, sock_fd);
+
+    switch (child_info_table[child_num].type)
+    {
+	case CHILD_TYPE_MULTIPLEXER:
+	    _DBG("type=MULTIPLEXER %d",child_num);
+	    break;
+	case CHILD_TYPE_PROCESSOR:
+	    _DBG("type=PROCESSOR %d",child_num);
+	    break;
+	default:
+	    _DBG("type UNKNOWN! %d",child_num);
+    }
+
+    if (sock_fd >= FD_SETSIZE) 
+    {
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
+                     "new file descriptor %d is too large; you probably need "
+                     "to rebuild Apache with a larger FD_SETSIZE "
+                     "(currently %d)", 
+                     sock_fd, FD_SETSIZE);
+        apr_socket_close(sock);
+	_DBG("thread_num=%d: exiting with error", thread_num);
+        return;
+    }
+
+    if (thread_info_table[thread_num].sock_fd < 0) 
+    {
+        ap_sock_disable_nagle(sock);
+    }
+
+    ap_create_sb_handle(&sbh, p, conn_id / thread_limit, thread_num);
+    _TRACE_CALL("ap_run_create_connection() [thread_num=%d]", thread_num);
+    current_conn = ap_run_create_connection(p, ap_server_conf, sock, conn_id, 
+                                            sbh, bucket_alloc);
+    _TRACE_RET("ap_run_create_connection() [thread_num=%d]", thread_num);
+    if (current_conn) 
+    {
+	_TRACE_CALL("ap_process_connection() [thread_num=%d]", thread_num);
+        ap_process_connection(current_conn, sock);
+	_TRACE_RET("ap_process_connection() [thread_num=%d]", thread_num);
+	_TRACE_CALL("ap_lingering_close() [thread_num=%d]", thread_num);
+        ap_lingering_close(current_conn);
+	_TRACE_RET("ap_lingering_close() [thread_num=%d]", thread_num);
+    }
+}
+
+static metuxmpm_process_connection(conn_rec *conn)
+{
+    ap_filter_t *filter;
+    apr_bucket_brigade *bb;
+    core_net_rec *net;
+
+    _DBG("function entered",0);
+
+    /* -- fetch our sockets from the pool -- */
+    apr_pool_userdata_get((void **)&bb, "metuxmpm_SOCKETS", conn->pool);
+    if (bb != NULL) 
+    {
+	/* -- find the 'core' filter and give the socket data to it -- */
+        for (filter = conn->output_filters; filter != NULL; filter = filter->next) 
+	{
+            if (!strcmp(filter->frec->name, "core")) break;
+        }
+        if (filter != NULL) 
+	{
+            net = filter->ctx;
+            net->in_ctx = apr_palloc(conn->pool, sizeof(*net->in_ctx));
+            net->in_ctx->b = bb;
+        }
+    }
+    _DBG("leaving (DECLINED)", 0);
+    return DECLINED;
+}
+    
+
+static void *worker_thread_proc(apr_thread_t *, void *);
+
+/* Starts a thread as long as we're below max_threads */
+static int start_thread(void)
+{
+    apr_thread_t *thread;
+    int rc;
+    int cnt;
+    
+    cnt = worker_thread_count_get ();
+    
+    _DBG("thread count currently: %d", cnt);
+    
+    if (cnt < max_threads - 1) 
+    {
+	_TRACE_CALL("apr_thread_create()",0);
+        rc = apr_thread_create(&thread, worker_thread_attr, worker_thread_proc,
+                 &worker_thread_free_ids[worker_thread_count], pchild);
+	_TRACE_RET("apr_thread_create()",0);
+	if (rc != APR_SUCCESS)
+	{
+            ap_log_error(APLOG_MARK, APLOG_ALERT, rc, ap_server_conf,
+                         "apr_thread_create: unable to create worker thread");
+            /* In case system resources are maxxed out, we don't want
+               Apache running away with the CPU trying to fork over and
+               over and over again if we exit. */
+            sleep(10);
+	    workers_may_exit = 1;
+	    _DBG("WATCH: workers_may_exit=%d", workers_may_exit);
+            return 0;
+        }
+	worker_thread_count_add ( 1 );
+        _DBG("WATCH: workers_may_exit=%d", workers_may_exit);
+	_DBG("ok",0);
+	return 1;
+    }
+
+    /* we already have too many threads running */
+    _DBG("too many running threads. aborting",0);
+    if (!thread_overflow_reported) 
+    {
+	ap_log_error(APLOG_MARK, APLOG_ERR, 0,
+                         ap_server_conf,
+                         "server reached MaxThreadsPerChild setting, "
+                         "consider raising the MaxThreadsPerChild or "
+                         "NumServers settings");
+        thread_overflow_reported = 1;
+    }
+    _DBG("WATCH: workers_may_exit=%d", workers_may_exit);
+    return 0;
+}
+
+/* Sets workers_may_exit if we received a character on the pipe_of_death */
+static apr_status_t check_pipe_of_death
+(
+    void **csd, 
+    ap_listen_rec *lr,
+    apr_pool_t *ptrans
+)
+{
+    int ret;
+    char pipe_read_char;
+    apr_size_t n = 1;
+
+    _DBG("WATCH: workers_may_exit=%d", workers_may_exit);
+
+    if (workers_may_exit) return APR_SUCCESS;
+    
+    apr_thread_mutex_lock(pipe_of_death_mutex);
+    ret = apr_recv(lr->sd, &pipe_read_char, &n);
+    if (APR_STATUS_IS_EAGAIN(ret)) 
+    {
+            /* It lost the lottery. It must continue to suffer
+             * through a life of servitude. */
+    }
+    else 
+    {
+	if (pipe_read_char != AP_metuxmpm_CHAR_OF_DEATH)
+	{
+	    _DBG("got wrong char %c", pipe_read_char);
+	    return APR_SUCCESS;
+	}	
+        /* It won the lottery (or something else is very
+         * wrong). Embrace death with open arms. */
+        workers_may_exit = 1;
+	_DBG("WATCH: workers_may_exit=%d", workers_may_exit);
+    }
+    apr_thread_mutex_unlock(pipe_of_death_mutex);
+    return APR_SUCCESS;
+}
+
+static apr_status_t receive_from_multiplexer 
+(
+    void **trans_sock, 	/* will be filled out w/ the received socket */
+    ap_listen_rec *lr,	/* listener to receive from */
+    apr_pool_t *ptrans	/* transaction wide pool */
+)
+{
+    struct msghdr msg;
+    struct cmsghdr *cmsg;
+    char headers[HUGE_STRING_LEN];
+    char *bodypart;
+    apr_size_t bodypart_len;
+    struct iovec iov[2];
+    int ret, fd_tmp;
+    apr_os_sock_t ctrl_sock_fd;
+    apr_os_sock_t trans_sock_fd;
+
+    /* -- bucket's, brigades and their allocators */
+    apr_bucket_alloc_t *alloc = apr_bucket_alloc_create(ptrans);
+    apr_bucket_brigade *bb    = apr_brigade_create(ptrans, alloc);
+    apr_bucket         *bucket;
+
+    /* prepare the buffers for receiving data from remote side */
+    iov[0].iov_base = &bodypart_len;
+    iov[0].iov_len  = sizeof(bodypart_len);
+    iov[1].iov_base = headers;
+    iov[1].iov_len  = HUGE_STRING_LEN;
+
+    cmsg = apr_palloc(ptrans, sizeof(*cmsg) + sizeof(trans_sock_fd));
+    cmsg->cmsg_len = sizeof(*cmsg) + sizeof(trans_sock_fd);
+
+    msg.msg_name       = NULL;
+    msg.msg_namelen    = 0;
+    msg.msg_iov        = iov;
+    msg.msg_iovlen     = 2;
+    msg.msg_control    = cmsg;
+    msg.msg_controllen = cmsg->cmsg_len;
+
+    /* -- receive data from socket -- */
+    apr_os_sock_get(&ctrl_sock_fd, lr->sd);
+    _DBG("receiving from sock_fd=%d", ctrl_sock_fd);
+    ret = recvmsg(ctrl_sock_fd, &msg, 0);
+    
+    /* -- extract socket from the cmsg -- */
+    memcpy(&trans_sock_fd, CMSG_DATA(cmsg), sizeof(trans_sock_fd));
+    apr_os_sock_put((apr_socket_t **)trans_sock, &trans_sock_fd, ptrans);
+    apr_os_sock_get(&fd_tmp, *trans_sock);
+
+
+    _DBG("trans_sock=%ld fdx=%d sock_fd=%d",
+         *trans_sock, trans_sock_fd, fd_tmp);
+
+    _DBG("headers=\"%s\"", headers);
+
+    /* -- store received data into an brigade and add 
+          it to the current transaction's pool -- */
+    bucket = apr_bucket_eos_create(alloc);
+    APR_BRIGADE_INSERT_HEAD(bb, bucket);
+    bucket = apr_bucket_socket_create(*trans_sock, alloc);
+    APR_BRIGADE_INSERT_HEAD(bb, bucket);
+
+    /* Receive the bodypart (if there is one) and insert it in the brigade */
+    if (bodypart_len) {       
+        _DBG("Receiving the bodypart (bodypart_len=%d)", bodypart_len);
+	bodypart = apr_palloc(ptrans, bodypart_len);
+        ret = recv(ctrl_sock_fd, bodypart, HUGE_STRING_LEN, 0);
+
+        _DBG("bodypart=\"%s\"", bodypart);
+        bucket = apr_bucket_heap_create(bodypart,
+                                        bodypart_len, NULL, alloc);
+        APR_BRIGADE_INSERT_HEAD(bb, bucket);
+    } else {
+        _DBG("There is no bodypart",0);
+    }
+    
+    bucket = apr_bucket_heap_create(headers,
+                                    strlen(headers), NULL, alloc);
+    /* DS: I really don't like that strlen here */
+    
+    APR_BRIGADE_INSERT_HEAD(bb, bucket);
+
+    apr_pool_userdata_set(bb, "metuxmpm_SOCKETS", NULL, ptrans);
+    _DBG("returning 0",0);
+    return 0;
+}
+
+/* idle_thread_count should be incremented before starting a worker_thread */
+
+static void *worker_thread_proc(apr_thread_t *thd, void *arg)
+{
+    apr_socket_t *sock;
+    apr_pool_t *tpool;      /* Pool for this thread           */
+    apr_pool_t *ptrans;     /* Pool for per-transaction stuff */
+    int srv;
+    int thread_num = *((int *) arg);
+    long conn_id = child_num * thread_limit + thread_num;
+    apr_pollfd_t *pollset;
+    apr_status_t rv;
+    ap_listen_rec *lr_walk;
+    int n;
+    int thread_cnt;
+    apr_bucket_alloc_t *bucket_alloc;
+
+    _DBG("function starting",0);
+    
+    /* === allocate thread pools etc === */
+    apr_thread_mutex_lock(thread_pool_parent_mutex);
+    apr_pool_create(&tpool, thread_pool_parent);
+    apr_thread_mutex_unlock(thread_pool_parent_mutex);
+    apr_pool_create(&ptrans, tpool);
+    
+    (void) ap_update_child_status_from_indexes(child_num, thread_num, 
+                                               SERVER_STARTING,
+                                               (request_rec *) NULL);
+
+    bucket_alloc = apr_bucket_alloc_create(apr_thread_pool_get(thd));
+
+    apr_thread_mutex_lock(idle_thread_count_mutex);
+    if (idle_thread_count < max_spare_threads) 
+    {
+        idle_thread_count++;
+	_DBG("idle_thread_count: %d", idle_thread_count);
+        apr_thread_mutex_unlock(idle_thread_count_mutex);
+    }
+    else 
+    {
+	_DBG("too many idle threads: %d (max %d)", idle_thread_count, max_spare_threads );
+        apr_thread_mutex_unlock(idle_thread_count_mutex);
+	goto worker_out;
+    }
+
+    while (!workers_may_exit)
+    {
+        apr_int16_t event;
+
+	_DBG("loop. conn_id=%d req_max=%d req_remain=%d", 
+	    conn_id, ap_max_requests_per_child, requests_this_child);
+	
+        ((ap_max_requests_per_child != 0) && 
+	 (requests_this_child < 1) && (workers_may_exit=1));
+
+	_DBG("WATCH: workers_may_exit=%d", workers_may_exit);
+	if (workers_may_exit) goto worker_out;
+
+        (void) ap_update_child_status_from_indexes(child_num, thread_num, 
+                                                   SERVER_READY,
+                                                   (request_rec *) NULL);
+
+	THREAD_ACCEPT_LOCK;
+
+        /* -- setup pollset -- */
+        /* NOTE: we do _not_ do this upwards anylonger */
+        apr_poll_setup(&pollset, num_listensocks, tpool);
+        apr_poll_setup(&pollset, num_listensocks, ptrans);
+        for(lr_walk = ap_listeners; lr_walk != NULL; lr_walk = lr_walk->next) 
+        {
+	    int fd;
+    	    apr_poll_socket_add(pollset, lr_walk->sd, APR_POLLIN);
+    	    apr_os_sock_get(&fd, lr_walk->sd);
+	    _DBG("adding fd %d to pollset", fd);
+        }
+
+	if (workers_may_exit) goto worker_out;
+        _TRACE_CALL("apr_poll()",0);
+        srv = apr_poll(pollset, num_listensocks, &n, -1);
+        _TRACE_RET("apr_poll()",0);
+
+	if (srv != APR_SUCCESS) 
+	{
+    	    if (APR_STATUS_IS_EINTR(srv)) 
+	    {
+		_DBG("apr_poll() has been interrupted", 0);
+		THREAD_ACCEPT_UNLOCK;
+                continue;
+            }
+
+            /* apr_poll() will only return errors in catastrophic
+             * circumstances. Let's try exiting gracefully, for now. */
+            ap_log_error(APLOG_MARK, APLOG_ERR, srv, (const server_rec *)
+                             ap_server_conf, "apr_poll: (listen)");
+            workers_may_exit = 1;
+	    _DBG("poll error!",0);
+	    _DBG("WATCH: workers_may_exit=%d", workers_may_exit);
+	    THREAD_ACCEPT_UNLOCK;
+	    goto worker_out;
+        }
+	    
+        /* find a listener */
+        _DBG("looking for an listener",0);
+	for (lr_walk=ap_listeners; lr_walk!=NULL; lr_walk = lr_walk->next)
+	{
+	    int fd_tmp;
+    	    apr_os_sock_get(&fd_tmp, lr_walk->sd);
+	    _DBG(" ... trying w/ fd=%d", fd_tmp);
+    	    apr_poll_revents_get(&event, lr_walk->sd, pollset);
+            if (event & (APR_POLLIN)) 
+	    {
+		THREAD_ACCEPT_UNLOCK;
+                goto got_fd;
+            }
+	    if (event & (APR_POLLERR)) 
+	    {
+		ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
+                             "got POLLERR in line 870");
+	    }
+        }
+
+	THREAD_ACCEPT_UNLOCK;
+	_DBG("WARN: did not find the right listener",0);
+	sleep ( 1 );
+	continue;
+
+    got_fd:
+	_DBG("input available ... resetting socket.",0);
+	sock = NULL;	/* important! */
+	
+	_TRACE_CALL("accept_func()",0);
+        rv = lr_walk->accept_func((void*)&sock, lr_walk, ptrans);
+	_TRACE_RET("accept_func()",0);
+	
+        if (rv == APR_EGENERAL) 
+	{
+            /* E[NM]FILE, ENOMEM, etc */
+	    _DBG("there was some error." ,0);
+            workers_may_exit = 1;
+	    _DBG("WATCH: workers_may_exit=%d", workers_may_exit);
+	    break;
+        }
+
+        apr_thread_mutex_lock(idle_thread_count_mutex);
+        if (idle_thread_count > min_spare_threads) 
+	{
+            idle_thread_count--;
+        }
+        else 
+	{
+            if (!start_thread()) 
+	    {
+                idle_thread_count--;
+            }
+        }
+        apr_thread_mutex_unlock(idle_thread_count_mutex);
+
+        if (!setjmp(thread_info_table[thread_num].jmpbuffer)) 
+	{
+	    _DBG("marked jmpbufffer",0);
+	    _TRACE_CALL("process_socket()",0);
+    	    process_socket(ptrans, sock, conn_id, bucket_alloc);
+	    _TRACE_RET("process_socket()",0);
+        }
+        else 
+	{
+	    _DBG("landed from longjmp",0);
+            thread_info_table[thread_num].sock_fd = AP_metuxmpm_THISCHILD;
+        }  
+        requests_this_child--;
+	apr_pool_clear(ptrans);
+    }
+
+    _DBG("thread loop finished",0);
+worker_out:
+    _DBG("this thread's work is done ... workers_may_exit=%d",workers_may_exit);
+
+    /* == think about it == */
+    apr_thread_mutex_lock(idle_thread_count_mutex);
+    idle_thread_count--;
+    apr_thread_mutex_unlock(idle_thread_count_mutex);
+
+    /* == */
+    apr_thread_mutex_lock(thread_pool_parent_mutex);
+    ap_update_child_status_from_indexes(child_num, thread_num, SERVER_DEAD,
+                                        (request_rec *) NULL);
+    apr_pool_destroy(tpool);
+    apr_thread_mutex_unlock(thread_pool_parent_mutex);
+    
+    thread_cnt = worker_thread_count_add ( -1 );
+    worker_thread_free_ids[thread_cnt] = thread_num;
+    if (!thread_cnt) 
+    {
+        /* All the threads have exited, now finish the shutdown process
+         * by signalling the sigwait thread */
+	_DBG("all workers have quit. killing myself (%d) with SIGTERM", my_pid);
+        kill(my_pid, SIGTERM);
+    }
+    else 
+    {
+	_DBG("this is not the time to die - %d threads are still alive", thread_cnt);
+	_DBG("WATCH: workers_may_exit=%d", workers_may_exit);
+    }
+
+    apr_bucket_alloc_destroy(bucket_alloc);
+    _DBG("leaving. good bye",0);
+    return NULL;
+}
+
+
+
+/* Set group privileges.
+ *
+ * Note that we use the username as set in the config files, rather than
+ * the lookup of to uid --- the same uid may have multiple passwd entries,
+ * with different sets of groups for each.
+ */
+
+static int set_group_privs(uid_t uid, gid_t gid)
+{
+    if (!geteuid()) 
+    {
+        const char *name;
+
+        /* Get username if passed as a uid */
+
+        struct passwd *ent;
+
+        if ((ent = getpwuid(uid)) == NULL) 
+	{
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                         "getpwuid: couldn't determine user name from uid %u, "
+                         "you probably need to modify the User directive",
+                         (unsigned)uid);
+            return -1;
+        }
+
+        name = ent->pw_name;
+
+        /*
+         * Set the GID before initgroups(), since on some platforms
+         * setgid() is known to zap the group list.
+         */
+        if (setgid(gid) == -1) 
+	{
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                         "setgid: unable to set group id to Group %u",
+                         (unsigned)gid);
+            return -1;
+        }
+
+        /* Reset `groups' attributes. */
+
+        if (initgroups(name, gid) == -1) 
+	{
+	            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                         "initgroups: unable to set groups for User %s "
+                         "and Group %u", name, (unsigned)gid);
+            return -1;
+        }
+    }
+    return 0;
+}
+
+
+static int metuxmpm_setup_child(int childnum)
+{
+    child_info_t *ug = &child_info_table[childnum];
+
+    if (ug->uid == -1 && ug->gid == -1) {
+        return unixd_setup_child();
+    }
+    if (set_group_privs(ug->uid, ug->gid)) {
+        return -1;
+    }
+    /* Only try to switch if we're running as root */
+    if (!geteuid()
+        && (
+#ifdef _OSD_POSIX
+            os_init_job_environment(server_conf, unixd_config.user_name,
+                                    one_process) != 0 ||
+#endif
+            setuid(ug->uid) == -1)) {
+        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                     "setuid: unable to change to uid: %ld",
+                     (long) ug->uid);
+        return -1;
+    }
+    return 0;
+}
+
+static int check_signal(int signum)
+{
+    _DBG("signum=%d", signum);
+    switch (signum) {
+    case SIGTERM:
+    case SIGINT:
+        just_die(signum);
+        return 1;
+    }
+    return 0;
+}                                                                               
+
+typedef struct metuxmpm_header 
+{
+    char *headers;
+    apr_pool_t *p;
+} metuxmpm_header;
+
+/* Send a single HTTP header field to the client.  Note that this function
+ * is used in calls to table_do(), so their interfaces are co-dependent.
+ * In other words, don't change this one without checking table_do in alloc.c.
+ * It returns true unless there was a write error of some kind.
+ */
+static int metuxmpm_header_field(metuxmpm_header *h,
+                             const char *fieldname, const char *fieldval)
+{
+    apr_pstrcat(h->p, h->headers, fieldname, ": ", fieldval, CRLF, NULL); 
+    return 1;
+}
+
+static inline ap_listen_rec* listen_add ( apr_pool_t* pool, apr_socket_t *sock, void* accept_func )
+{
+    ap_listen_rec *lr_walk, *lr_new;
+    
+    _DBG("function started",0);
+    /* -- create an new listener for this child -- */
+    lr_new = apr_palloc(pool, sizeof(*lr_new));
+    lr_new->sd          = sock;
+    lr_new->active      = 1;
+    lr_new->accept_func = accept_func;
+    lr_new->next        = NULL;
+
+    /* -- add the new listener_rec into the list -- */
+    /* FIXME: should we somehow lock this list ? */
+    if (lr_walk = ap_listeners) 
+    {
+	while (lr_walk->next) lr_walk = lr_walk->next;
+	lr_walk->next = lr_new;
+    }
+    else
+    {
+	ap_listeners = lr_walk = lr_new; 
+    }
+    num_listensocks++;
+    return lr_new;
+}
+
+static inline void listen_clear ()
+{
+    ap_listen_rec *lr_walk;
+    
+    _DBG("function started",0);
+
+    /* FIXME: should we somehow lock this list ? */
+    while (ap_listeners)
+    {
+	lr_walk = ap_listeners->next;
+	apr_socket_close(ap_listeners->sd);
+	ap_listeners = lr_walk;
+    }
+    num_listensocks=0;
+}
+
+/* -- main routine of an child process -- */
+static void child_main(int child_num_arg)
+{
+    int i;
+    apr_status_t rv;
+    apr_socket_t *sock = NULL;
+    
+    my_pid    = getpid();
+    child_num = child_num_arg;
+
+    _DBG("sock_fd_in=%d sock_fd_out=%d", child_info_table[child_num].input, child_info_table[child_num].output );
+    
+    /* -- allocate an new pool for us -- */
+    apr_pool_create(&pchild, pconf);
+    if (child_info_table[child_num].chroot_dir){
+      _DBG("chroot to %s",child_info_table[child_num].chroot_dir);
+      if (chroot(child_info_table[child_num].chroot_dir)){
+        _DBG("chroot failure %s",child_info_table[child_num].chroot_dir);
+        return;
+      }
+    }
+
+    switch (child_info_table[child_num].type)
+    {
+	case CHILD_TYPE_MULTIPLEXER:
+	    _DBG("MULTIPLEXER %d", child_num);
+	    break;
+	    
+	case CHILD_TYPE_PROCESSOR:
+	    _DBG("PROCESSOR %d", child_num);
+
+	    /* -- create new listener to receive from multiplexer -- */
+	    apr_os_sock_put(&sock, &child_info_table[child_num].input, pconf);
+	    listen_clear ();
+	    listen_add ( pconf, sock, receive_from_multiplexer );
+	    break;
+	
+	default:
+	    _DBG("unspecified child type for %d sleeping a while ...", child_num);
+	    sleep ( 5 );
+	    return;
+    }
+    /*stuff to do before we switch id's, so we have permissions.*/
+
+    /* -- init child process (uid switching etc) -- */
+    (metuxmpm_setup_child(child_num) && clean_child_exit(APEXIT_CHILDFATAL));
+    ap_run_child_init(pchild, ap_server_conf);
+
+    /*done with init critical section */
+
+    apr_setup_signal_thread();
+
+    requests_this_child = ap_max_requests_per_child;
+    
+    /* Setup worker threads */
+
+    _DBG("setting up worker threads ... " ,0);
+    ((threads_to_start > max_threads) && (threads_to_start = max_threads));
+    idle_thread_count = threads_to_start;
+    workers_may_exit    = 0;
+    worker_thread_count = 0;
+    worker_thread_free_ids = (int *)apr_pcalloc(pchild, thread_limit * sizeof(int));
+    for (i = 0; i < max_threads; i++) 
+    {
+        worker_thread_free_ids[i] = i;
+    }
+    apr_pool_create(&thread_pool_parent, pchild);
+    apr_thread_mutex_create(&thread_pool_parent_mutex, 
+                    APR_THREAD_MUTEX_DEFAULT, pchild);
+    apr_thread_mutex_create(&idle_thread_count_mutex, 
+                    APR_THREAD_MUTEX_DEFAULT, pchild);
+    apr_thread_mutex_create(&worker_thread_count_mutex,
+                    APR_THREAD_MUTEX_DEFAULT, pchild);
+    apr_thread_mutex_create(&pipe_of_death_mutex,
+                    APR_THREAD_MUTEX_DEFAULT, pchild);
+    apr_thread_mutex_create(&thread_accept_mutex,
+                    APR_THREAD_MUTEX_DEFAULT, pchild);
+
+    apr_threadattr_create(&worker_thread_attr, pchild);
+    apr_threadattr_detach_set(worker_thread_attr, 1);                                     
+
+    /* We are creating worker threads right now */
+    for (i=0; i < threads_to_start; i++) 
+    {
+        /* start_thread shouldn't fail here */
+	_TRACE_CALL("start_thread()",0);
+        if (!start_thread()) break;
+	_TRACE_RET("start_thread()",0);
+    }
+
+    _TRACE_CALL("apr_signal_thread()",0);
+    apr_signal_thread(check_signal);
+    _TRACE_RET("apr_signal_thread",0);
+}
+
+static int make_child(server_rec *s, int slot)
+{
+    int pid;
+
+    switch (child_info_table[slot].type)
+    {
+	case CHILD_TYPE_MULTIPLEXER:		break;
+	case CHILD_TYPE_PROCESSOR:		break;
+	default:
+	    _DBG("no valid client in slot %d", slot);
+	    sleep(1);
+	    return 0;
+    }
+
+    if (slot + 1 > ap_max_daemons_limit) 
+    {
+        ap_max_daemons_limit = slot + 1;
+    }
+
+    (void) ap_update_child_status_from_indexes(slot, 0, SERVER_STARTING,
+                                               (request_rec *) NULL);
+
+    if ((pid = fork()) == -1) 
+    {
+        ap_log_error(APLOG_MARK, APLOG_ERR, errno, s,
+                     "fork: Unable to fork new process");
+        /* In case system resources are maxxed out, we don't want
+         * Apache running away with the CPU trying to fork over and
+         * over and over again. */
+        sleep(10);
+
+        return -1;
+    }
+
+    if (!pid) 
+    {
+#ifdef HAVE_BINDPROCESSOR
+        /* By default, AIX binds to a single processor.  This bit unbinds
+         * children which will then bind to another CPU.
+         */
+        int status = bindprocessor(BINDPROCESS, (int)getpid(),
+                                   PROCESSOR_CLASS_ANY);
+        if (status != OK) {
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, 
+                         ap_server_conf, "processor unbind failed %d", status);
+        }
+#endif
+
+        RAISE_SIGSTOP(MAKE_CHILD);
+
+        /* XXX - For an unthreaded server, a signal handler will be necessary
+         * apr_signal(SIGTERM, just_die);
+         */
+        child_main(slot);
+        clean_child_exit(0);
+    }
+    /* else */
+    ap_scoreboard_image->parent[slot].pid = pid;
+
+    ap_child_table[slot].pid    = pid;
+    ap_child_table[slot].status = SERVER_ALIVE;
+
+    return 0;
+}
+
+/* start up a bunch of children */
+static int startup_children(int number_to_start)
+{
+    int i;
+
+    for (i = 0; number_to_start && i < num_childs; ++i) 
+    {
+        if (ap_child_table[i].pid)  continue;
+        if (make_child(ap_server_conf, i) < 0) break;
+        --number_to_start;
+    }
+    return number_to_start;
+}
+
+
+/*
+ * spawn_rate is the number of children that will be spawned on the
+ * next maintenance cycle if there aren't enough servers.  It is
+ * doubled up to MAX_SPAWN_RATE, and reset only when a cycle goes by
+ * without the need to spawn.
+ */
+static int spawn_rate = 1;
+#ifndef MAX_SPAWN_RATE
+#define MAX_SPAWN_RATE  (32)
+#endif
+static int hold_off_on_exponential_spawning;
+
+static void perform_child_maintenance(void)
+{
+    int i;
+    int free_length;
+    int free_slots[MAX_SPAWN_RATE];
+    int last_non_dead = -1;
+
+    /* initialize the free_list */
+    free_length = 0;
+    
+    for (i = 0; i < num_childs; ++i) 
+    {
+        if (ap_child_table[i].pid == 0) 
+	{
+            if (free_length < spawn_rate) 
+	    {
+                free_slots[free_length] = i;
+                ++free_length;
+            }
+        }
+        else 
+	{
+            last_non_dead = i;
+        }
+
+        if (i >= ap_max_daemons_limit && free_length >= spawn_rate) 
+	{
+            break;
+        }
+    }
+    ap_max_daemons_limit = last_non_dead + 1;
+
+    if (free_length > 0) 
+    {
+        for (i = 0; i < free_length; ++i) 
+	{
+	    _TRACE_CALL("make_child()",0);
+            make_child(ap_server_conf, free_slots[i]);
+	    _TRACE_RET("make_child()",0);
+        }
+        /* the next time around we want to spawn twice as many if this
+         * wasn't good enough, but not if we've just done a graceful
+         */
+        if (hold_off_on_exponential_spawning) 
+	{
+            --hold_off_on_exponential_spawning;
+        }
+        else if (spawn_rate < MAX_SPAWN_RATE) 
+	{
+            spawn_rate *= 2;
+        }
+    }
+    else 
+    {
+        spawn_rate = 1;
+    }
+}
+
+static void server_main_loop(int remaining_children_to_start)
+{
+    apr_exit_why_e exitwhy;
+    apr_proc_t pid;
+    int child_slot;
+    int status;
+    int i;
+    static int l=0;
+    
+    while (!restart_pending && !shutdown_pending) 
+    {
+        ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);
+        
+        if (pid.pid != -1) 
+	{
+            if (ap_process_child_status(&pid, exitwhy, status)==APEXIT_CHILDFATAL) 
+	    {
+		_DBG("shutdown pending ...",0);
+                shutdown_pending = 1;
+                child_fatal = 1;
+                return;
+            }
+            /* non-fatal death... note that it's gone in the child table and
+             * clean out the status table. */
+	    _DBG("child has #%d died ...", child_slot);
+            child_slot = -1;
+            for (i = 0; i < ap_max_daemons_limit; ++i) 
+	    {
+                if (ap_child_table[i].pid == pid.pid) 
+		{
+                    child_slot = i;
+                    break;
+                }
+            }
+            if (child_slot >= 0) 
+	    {
+                ap_child_table[child_slot].pid = 0;
+                ap_update_child_status_from_indexes(child_slot, i, SERVER_DEAD,
+                                                    (request_rec *) NULL);
+
+                
+                if (remaining_children_to_start && (child_slot < num_childs))
+		{
+                    /* we're still doing a 1-for-1 replacement of dead
+                     * children with new children
+                     */
+		    _DBG("replacing by new child ...",0);
+                    make_child(ap_server_conf, child_slot);
+                    --remaining_children_to_start;
+                }
+#if APR_HAS_OTHER_CHILD
+            }
+            else if (apr_proc_other_child_read(&pid, status) == 0) 
+	    {
+            /* handled */
+#endif
+            }
+            else if (is_graceful) 
+	    {
+                /* Great, we've probably just lost a slot in the
+                * child table.  Somehow we don't know about this
+                * child.
+                */
+                ap_log_error(APLOG_MARK, APLOG_WARNING, 0, 
+                             ap_server_conf,
+                             "long lost child came home! (pid %ld)", 
+                             (long)pid.pid);
+            }
+            /* Don't perform idle maintenance when a child dies,
+             * only do it when there's a timeout.  Remember only a
+             * finite number of children can die, and it's pretty
+             * pathological for a lot to die suddenly.
+             */
+            continue;
+        }
+        else if (remaining_children_to_start) 
+	{
+            /* we hit a 1 second timeout in which none of the previous
+             * generation of children needed to be reaped... so assume
+             * they're all done, and pick up the slack if any is left.
+             */
+	    _TRACE_CALL("startup_children()",0);
+            remaining_children_to_start = startup_children(remaining_children_to_start);
+	    _TRACE_RET("startup_children()",0);
+            /* In any event we really shouldn't do the code below because
+             * few of the servers we just started are in the IDLE state
+             * yet, so we'd mistakenly create an extra server.
+             */
+            continue;
+        }
+	
+        perform_child_maintenance();
+    }
+}
+
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
+{
+    int remaining_children_to_start;
+    int i;
+    int fd;
+    apr_status_t rv;
+    apr_size_t one = 1;
+    apr_socket_t *sock = NULL;
+
+    ap_log_pid(pconf, ap_pid_fname);
+
+    first_server_limit = server_limit;
+    first_thread_limit = thread_limit;
+    if (changed_limit_at_restart) 
+    {
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                     "WARNING: Attempt to change ServerLimit or ThreadLimit "
+                     "ignored during restart");
+        changed_limit_at_restart = 0;
+    }
+
+    ap_server_conf = s;
+
+    /* Initialize cross-process accept lock */
+    ap_lock_fname = apr_psprintf(_pconf, "%s.%u",
+                                 ap_server_root_relative(_pconf, ap_lock_fname),
+                                 my_pid);
+    rv = ACCEPT_PROC_MUTEX_CREATE;
+    if (rv != APR_SUCCESS) 
+    {
+        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
+                     "Couldn't create cross-process lock");
+        return 1;
+    }
+
+    if (!is_graceful) 
+    {
+        if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) 
+	{
+            return 1;
+        }
+    }
+    /* Initialize the child table */
+    if (!is_graceful) 
+    {
+        for (i = 0; i < server_limit; i++) 
+	{
+            ap_child_table[i].pid = 0;
+        }
+    }
+
+    /* We need to put the new listeners at the end of the ap_listeners
+     * list.  If we don't, then the pool will be cleared before the
+     * open_logs phase is called for the second time, and ap_listeners
+     * will have only invalid data.  If that happens, then the sockets
+     * that we opened using make_sock() will be lost, and the server
+     * won't start.
+     */
+    apr_os_file_get(&fd, pipe_of_death_in);
+    apr_os_sock_put(&sock, &fd, pconf);
+
+    listen_add ( pconf, sock, check_pipe_of_death );
+    set_signals();
+
+    /* If we're doing a graceful_restart then we're going to see a lot
+     * of children exiting immediately when we get into the main loop
+     * below (because we just sent them AP_SIG_GRACEFUL).  This happens 
+     * pretty rapidly... and for each one that exits we'll start a new one 
+     * until we reach at least daemons_min_free.  But we may be permitted to
+     * start more than that, so we'll just keep track of how many we're
+     * supposed to start up without the 1 second penalty between each fork.
+     */
+    remaining_children_to_start = num_childs;
+    if (!is_graceful) {
+        remaining_children_to_start = \
+            startup_children(remaining_children_to_start);
+    }
+    else {
+        /* give the system some time to recover before kicking into
+         * exponential mode */
+        hold_off_on_exponential_spawning = 10;
+    }
+
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+                 "%s configured -- resuming normal operations",
+                 ap_get_server_version());
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+                 "Server built: %s", ap_get_server_built());
+#ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
+#ifdef NO_SERIALIZED_ACCEPT
+    _DBG("AcceptMutex: n/a (compiled w/ NO_SERIALIZED_ACCEPT)", 0 );
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+		"AcceptMutex: n/a (compiled w/ NO_SERIALIZED_ACCEPT)" );
+#else
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+		"AcceptMutex: %s (default: %s)",
+		apr_proc_mutex_name(process_accept_mutex),
+		apr_proc_mutex_defname());
+#endif
+#endif
+    restart_pending = shutdown_pending = 0;
+
+    server_main_loop(remaining_children_to_start);
+
+    if (shutdown_pending) 
+    {
+        /* Time to gracefully shut down:
+         * Kill child processes, tell them to call child_exit, etc...
+         */
+        if (unixd_killpg(getpgrp(), SIGTERM) < 0) 
+	{
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                         "killpg SIGTERM");
+        }
+        ap_reclaim_child_processes(1);      /* Start with SIGTERM */
+
+        if (!child_fatal) 
+	{
+            /* cleanup pid file on normal shutdown */
+            const char *pidfile = NULL;
+            pidfile = ap_server_root_relative (pconf, ap_pid_fname);
+            if (pidfile != NULL && unlink(pidfile) == 0) {
+                ap_log_error(APLOG_MARK, APLOG_INFO, 0,
+                             ap_server_conf,
+                             "removed PID file %s (pid=%ld)",
+                             pidfile, (long)getpid());
+            }
+    
+            ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
+                         ap_server_conf, "caught SIGTERM, shutting down");
+        }
+        return 1;
+    }
+
+    /* we've been told to restart */
+    apr_signal(SIGHUP, SIG_IGN);
+
+    if (one_process) return 1;	    /* not worth thinking about */
+
+    if (is_graceful) 
+    {
+        char char_of_death = AP_metuxmpm_CHAR_OF_DEATH;
+
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
+                     ap_server_conf, AP_SIG_GRACEFUL_STRING " received.  "
+                     "Doing graceful restart");
+
+        /* This is mostly for debugging... so that we know what is still
+         * gracefully dealing with existing request.
+         */
+    
+        for (i = 0; i < num_childs; ++i) 
+	{
+            ((ap_child_table[i].pid) && (ap_child_table[i].status = SERVER_DYING));
+        }
+	
+        /* give the children the signal to die */
+        for (i = 0; i < num_childs;) 
+	{
+            if ((rv = apr_file_write(pipe_of_death_out, &char_of_death,&one)) != APR_SUCCESS) 
+	    {
+                if (APR_STATUS_IS_EINTR(rv)) continue;
+                ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
+                             "write pipe_of_death");
+            }
+            i++;
+        }
+    }
+    else 
+    {
+        /* Kill 'em all.  Since the child acts the same on the parents SIGTERM 
+         * and a SIGHUP, we may as well use the same signal, because some user
+         * pthreads are stealing signals from us left and right.
+         */
+        if (unixd_killpg(getpgrp(), SIGTERM) < 0) 
+	{
+            ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf,
+                         "killpg SIGTERM");
+        }
+        ap_reclaim_child_processes(1);      /* Start with SIGTERM */
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
+                     ap_server_conf, "SIGHUP received.  Attempting to restart");
+    }
+    return 0;
+}
+
+/* This really should be a post_config hook, but the error log is already
+ * redirected by that point, so we need to do this in the open_logs phase.
+ */
+static int metuxmpm_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
+{
+    apr_status_t rv;
+
+    pconf = p;
+    ap_server_conf = s;
+
+    _DBG("port=%d", ap_server_conf->port);
+    
+    if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {
+        ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0,
+                     NULL, "metuxmpm_open_logs(): no listening sockets available, shutting down");
+        return DONE;
+    }
+
+    ap_log_pid(pconf, ap_pid_fname);
+
+    if ((rv = ap_mpm_pod_open(pconf, &pod))) {
+        ap_log_error(APLOG_MARK, APLOG_CRIT|APLOG_STARTUP, rv, NULL,
+                "Could not open pipe-of-death.");
+        return DONE;
+    }
+
+    if ((rv = apr_file_pipe_create(&pipe_of_death_in, &pipe_of_death_out,
+                                   pconf)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv,
+                     (const server_rec*) ap_server_conf,
+                     "apr_file_pipe_create (apipe_of_death)");
+        exit(1);
+    }
+    if ((rv = apr_file_pipe_timeout_set(pipe_of_death_in, 0)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv,
+                     (const server_rec*) ap_server_conf,
+                     "apr_file_pipe_timeout_set (pipe_of_death)");
+        exit(1);
+    }
+
+    return OK;
+}
+
+static int metuxmpm_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
+{
+    static int restart_num = 0;
+    int no_detach, debug, foreground;
+    ap_directive_t *pdir;
+    int i;
+    int tmp_server_limit = DEFAULT_SERVER_LIMIT;
+    int tmp_thread_limit = DEFAULT_THREAD_LIMIT;
+    apr_status_t rv;
+
+    debug = ap_exists_config_define("DEBUG");
+
+    if (debug) {
+        foreground = one_process = 1;
+        no_detach = 0;
+    }
+    else {
+        one_process = ap_exists_config_define("ONE_PROCESS");
+        no_detach = ap_exists_config_define("NO_DETACH");
+        foreground = ap_exists_config_define("FOREGROUND");
+    }
+
+    /* FIXME */
+/*    no_detach = 0;
+    foreground = 0; */
+    
+    /* sigh, want this only the second time around */
+    if (restart_num++ == 1) 
+    {
+        is_graceful = 0;
+
+        if (!one_process && !foreground) 
+	{
+            rv = apr_proc_detach(no_detach ? APR_PROC_DETACH_FOREGROUND
+                                           : APR_PROC_DETACH_DAEMONIZE);
+            if (rv != APR_SUCCESS) {
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                             "apr_proc_detach failed");
+                return HTTP_INTERNAL_SERVER_ERROR;
+            }                  
+        }
+
+        my_pid = getpid();
+    }
+
+    unixd_pre_config(ptemp);
+    ap_listen_pre_config();
+//    num_childs = DEFAULT_NUM_DAEMON;
+    num_childs = 0;
+    threads_to_start = DEFAULT_START_THREAD;
+    min_spare_threads = DEFAULT_MIN_SPARE_THREAD;
+    max_spare_threads = DEFAULT_MAX_SPARE_THREAD;
+    max_threads = thread_limit;
+    ap_pid_fname = DEFAULT_PIDLOG;
+    ap_lock_fname = DEFAULT_LOCKFILE;
+    ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
+
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+
+    /* we need to know ServerLimit and ThreadLimit before we start processing
+     * the tree because we need to already have allocated child_info_table
+     */
+    for (pdir = ap_conftree; pdir != NULL; pdir = pdir->next) 
+    {
+        if (!strcasecmp(pdir->directive, "ServerLimit")) 
+	{
+            if (atoi(pdir->args) > tmp_server_limit) 
+	    {
+                tmp_server_limit = atoi(pdir->args);
+                if (tmp_server_limit > MAX_SERVER_LIMIT) 
+		{
+                    tmp_server_limit = MAX_SERVER_LIMIT;
+                }
+            }
+        }
+        else if (!strcasecmp(pdir->directive, "ThreadLimit")) 
+	{
+            if (atoi(pdir->args) > tmp_thread_limit) 
+	    {
+                tmp_thread_limit = atoi(pdir->args);
+                if (tmp_thread_limit > MAX_THREAD_LIMIT) 
+		{
+                    tmp_thread_limit = MAX_THREAD_LIMIT;
+                }
+            }
+        }
+    }
+
+    /* -- now setup the child information table -- */
+    child_info_table = (child_info_t *)apr_pcalloc(p, tmp_server_limit * sizeof(child_info_t));
+    child_info_table_size = tmp_server_limit; /* FIXME: remove tmp_server_limit */
+    for (i = 0; i < tmp_server_limit; i++) 
+    {
+        child_info_table[i].uid    = -1;
+        child_info_table[i].gid    = -1;
+        child_info_table[i].input  = -1;
+        child_info_table[i].output = -1;
+	child_info_table[i].type   = -1;
+	child_info_table[i].id     = i;
+    }
+
+    return OK;
+}
+
+#undef NO_BODY
+
+static int pass_request(request_rec *r)
+{
+    int rv;
+    struct msghdr msg;
+    struct cmsghdr *cmsg;
+    int sock_fd;
+    char *bodypart = NULL;
+    struct iovec iov[2];
+    conn_rec *c = r->connection;
+    apr_bucket_brigade *bb = apr_brigade_create(r->pool, c->bucket_alloc);
+    apr_bucket_brigade *bodypart_bb = NULL;
+    apr_size_t len = 0;
+    apr_size_t bodypart_len = 0;
+    metuxmpm_header h;
+    apr_bucket *bucket;
+    const apr_array_header_t *headers_in_array;
+    const apr_table_entry_t *headers_in;
+    int counter;
+
+    apr_socket_t *thesock = ap_get_module_config(r->connection->conn_config, &core_module);
+    metuxmpm_server_conf *sconf = metuxmpm_SERVER_CONF(r->server->module_config);
+
+    if ((!r->the_request) || (!strlen(r->the_request)))
+    {
+	_DBG("empty request. dropping it (%ld)", r->the_request);
+	return -1;
+    }
+
+    if (!sconf->child)
+    {
+	_DBG("server %s in child %d has no child_info assiocated",
+		r->hostname, child_num);
+	return -1;
+    }	
+
+    _DBG("passing request to another child.  Vhost: %s, child %d %d",
+                apr_table_get(r->headers_in, "Host"), child_num, sconf->child->output);
+    _DBG("r->the_request=\"%s\" len=%d", r->the_request, strlen(r->the_request));
+
+    ap_get_brigade(r->connection->input_filters, bb, AP_MODE_EXHAUSTIVE, APR_NONBLOCK_READ, len);
+
+    /* Scan the brigade looking for heap-buckets */
+    
+    _DBG("Scanning the brigade",0);
+    bucket = APR_BRIGADE_FIRST(bb);
+    while (bucket != APR_BRIGADE_SENTINEL(bb) &&
+           APR_BUCKET_IS_HEAP(bucket)) {
+       _DBG("HEAP BUCKET is found, length=%d", bucket->length);
+        bucket = APR_BUCKET_NEXT(bucket);
+	if (!APR_BUCKET_IS_HEAP(bucket)) {
+  	    _DBG("NON-HEAP BUCKET is found, extracting the part of brigade before it",0);
+	    bodypart_bb = bb;
+	    bb = apr_brigade_split(bodypart_bb, bucket);
+	    /* Do we need to apr_destroy_brigade(bb) here? 
+	     * Yeah, I know we do apr_pool_destroy(r->pool) before return, but
+	     * ap_get_brigade is in non-blocking mode (however len is zero).
+	     */
+            if (apr_brigade_pflatten(bodypart_bb, &bodypart, &bodypart_len, r->pool) != APR_SUCCESS) {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                     "Unable to flatten brigade, declining request");
+		apr_pool_destroy(r->pool);
+                return DECLINED;
+            }
+  	    _DBG("Brigade is flattened as bodypart (bodypart_len=%d)", bodypart_len);    
+	}
+    }
+    _DBG("Scanning is finished",0);
+
+    apr_os_sock_get(&sock_fd, thesock);
+
+    h.p = r->pool;
+
+    headers_in_array = apr_table_elts(r->headers_in);
+    headers_in = (const apr_table_entry_t *) headers_in_array->elts;
+    
+    h.headers = apr_pstrcat(h.p, r->the_request, CRLF, NULL);
+    for (counter = 0; counter < headers_in_array->nelts; counter++) {
+        if (headers_in[counter].key == NULL
+         || headers_in[counter].val == NULL) {
+             continue;
+         }
+         h.headers = apr_pstrcat(h.p, h.headers, headers_in[counter].key, ": ",
+                                 headers_in[counter].val, CRLF, NULL);
+			 
+    }
+    h.headers = apr_pstrcat(h.p, h.headers, CRLF, NULL);
+    ap_xlate_proto_to_ascii(h.headers, strlen(h.headers));
+
+    iov[0].iov_base = &bodypart_len;
+    iov[0].iov_len  = sizeof(bodypart_len);
+    iov[1].iov_base = h.headers;
+    iov[1].iov_len  = strlen(h.headers) + 1;
+    
+    msg.msg_name    = NULL;
+    msg.msg_namelen = 0;
+    msg.msg_iov     = iov;
+    msg.msg_iovlen  = 2;
+
+    cmsg = apr_palloc(r->pool, sizeof(*cmsg) + sizeof(sock_fd));
+    cmsg->cmsg_len   = sizeof(*cmsg) + sizeof(sock_fd);
+    cmsg->cmsg_level = SOL_SOCKET;
+    cmsg->cmsg_type  = SCM_RIGHTS;
+
+    memcpy(CMSG_DATA(cmsg), &sock_fd, sizeof(sock_fd));
+
+    msg.msg_control    = cmsg;
+    msg.msg_controllen = cmsg->cmsg_len;
+
+    _DBG("Writing message to %d, passing sock_fd:  %d", sconf->child->output, sock_fd);
+    _DBG("headers=\"%s\"", h.headers);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+                 "Writing message to %d, passing sd:  %d", sconf->child->output, sock_fd);
+
+    if ((rv = sendmsg(sconf->child->output, &msg, 0)) == -1) 
+    {
+        apr_pool_destroy(r->pool);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+                     "Writing message failed %d %d", rv, errno);
+        return -1;
+    }
+
+    _DBG("Writing message succeeded %d", rv);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+                 "Writing message succeeded %d", rv);
+
+    if (bodypart_len) {
+        _DBG("Passing bodypart (bodypart_len=%d) \"%s\"", bodypart_len, bodypart);
+         if ((rv = send(sconf->child->output, bodypart, bodypart_len, 0)) == -1) {
+             apr_pool_destroy(r->pool);
+	     ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+			  "Writing message failed %d %d", rv, errno);
+	     return -1;
+         }
+        _DBG("Writing message succeeded %d", rv);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf, 
+                     "Writing message succeeded %d", rv);
+    } else {
+        _DBG("No bodypart",0);
+    }
+
+    /* -- close the socket at our site -- */
+    apr_socket_close(thesock);
+    /* DS: What is the purpose of this?
+     *     apr_socket_close(sconf->child->output) seems more reasonable 
+     */
+    _DBG("closing socket %d at our side", sock_fd);
+    apr_pool_destroy(r->pool);
+    return 1;
+}
+
+static int metuxmpm_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *server_list)
+{
+    int i;
+    server_rec *sr_walk;
+    metuxmpm_server_conf *sconf;
+
+    for (sr_walk = server_list; sr_walk; sr_walk = sr_walk->next) 
+    {
+        sconf = metuxmpm_SERVER_CONF(sr_walk->module_config);
+	if (sconf->child)
+	{
+	    _DBG("server \"%s\" child=%d fd_in=%d fd_out=%d", 
+		    sr_walk->server_hostname,
+		    sconf->child->id, 
+		    sconf->child->input, 
+		    sconf->child->output );
+	}
+	else
+	{
+	    _DBG("server \"%s\" has no child assiocated.",
+		    sr_walk->server_hostname);
+	}
+    }
+
+    thread_info_table = (thread_info_t *)apr_pcalloc(p, thread_limit * sizeof(thread_info_t));
+    for (i = 0; i < thread_limit; i++) 
+    {
+        thread_info_table[i].sock_fd = AP_metuxmpm_THISCHILD;
+	thread_info_table[i].status  = 0;
+    }
+    ap_child_table = (ap_ctable *)apr_pcalloc(p, server_limit * sizeof(ap_ctable));
+
+    return OK;
+}
+
+static int metuxmpm_post_read(request_rec *r)
+{
+    int thread_num = r->connection->id % thread_limit;
+    metuxmpm_server_conf *sconf = metuxmpm_SERVER_CONF(r->server->module_config);
+
+    if (!strlen(r->the_request)) 
+    {
+	_DBG("corrupt request. aborting",0);
+	return DECLINED;
+    }
+
+    if (thread_info_table[thread_num].sock_fd != AP_metuxmpm_THISCHILD) 
+    {
+        apr_socket_t *sock = NULL;
+
+        apr_os_sock_put(&sock, &thread_info_table[thread_num].sock_fd, 
+                        r->connection->pool);
+        ap_sock_disable_nagle(sock);
+        ap_set_module_config(r->connection->conn_config, &core_module, sock);
+	_DBG("not the right socket? ",0);
+        return OK;
+    }
+
+    switch (child_info_table[child_num].type)
+    {
+	case CHILD_TYPE_MULTIPLEXER:
+	{
+	    _DBG("MULTIPLEXER => Determining if request should be passed. "
+        	 "Child Num: %d, dest-child: %d, hostname from server: %s r->hostname=%s r->the_request=\"%s\"", 
+	    	child_num, sconf->child->id, r->server->server_hostname, r->hostname, r->the_request);
+
+	    if (sconf->child->id != child_num)
+	    {
+    		_DBG("Passing request.",0);
+    		if (pass_request(r) == -1) 
+	        {
+        	    ap_log_error(APLOG_MARK, APLOG_ERR, 0,
+                             ap_server_conf, "Could not pass request to proper "
+                             "child, request will not be honoured.");
+		    return DECLINED;
+	        }
+		_DBG("doing longjmp",0);
+		longjmp(thread_info_table[thread_num].jmpbuffer, 1); 
+		_DBG("request declined at our site",0);
+		return DECLINED;
+		_DBG("OUH! we should never reach this point",0);
+	    }
+	    _DBG("eeeh?! the server is assigned to the multiplexer! ... dropping request",0);
+	    return DECLINED;
+	}
+	case CHILD_TYPE_PROCESSOR:
+	{
+	    _DBG("PROCESSOR %d", child_num );
+	    if (sconf->child->id != child_num) 
+	    {
+		_DBG("hmmpf! this server is not assigned to us! what did the mux have smoked ?!",0);
+	    }
+	    _DBG("request for %s / (server %s) seems to be for us", r->hostname, r->server->server_hostname );
+	    return OK;
+	}
+	default:
+	{
+	    _DBG("unspecified child type %d in %d, dropping request", child_info_table[child_num].type, child_num );
+	    return OK;
+	}
+    }    
+    _DBG("THIS POINT SHOULD NOT BE REACHED!",0);
+    return OK;
+}
+
+static void metuxmpm_hooks(apr_pool_t *p)
+{
+    /* The metuxmpm open_logs phase must run before the core's, or stderr
+     * will be redirected to a file, and the messages won't print to the
+     * console.
+     */
+    static const char *const aszSucc[] = {"core.c", NULL};
+    one_process = 0;
+
+    ap_hook_open_logs(metuxmpm_open_logs, NULL, aszSucc, APR_HOOK_MIDDLE);
+    ap_hook_pre_config(metuxmpm_pre_config, NULL, NULL, APR_HOOK_MIDDLE); 
+    ap_hook_post_config(metuxmpm_post_config, NULL, NULL, APR_HOOK_MIDDLE); 
+
+    /* Both of these must be run absolutely first.  If this request isn't for 
+     * this server then we need to forward it to the proper child.  No sense
+     * tying up this server running more post_read request hooks if it is
+     * just going to be forwarded along.  The process_connection hook allows
+     * metuxmpm to receive the passed request correctly, by automatically
+     * filling in the core_input_filter's ctx pointer.
+     */
+    ap_hook_post_read_request(metuxmpm_post_read, NULL, NULL,
+                              APR_HOOK_REALLY_FIRST);
+    ap_hook_process_connection(metuxmpm_process_connection, NULL, NULL, 
+                               APR_HOOK_REALLY_FIRST);
+}
+
+//static const char *cf_NumServers(cmd_parms *cmd, void *dummy,
+//                                   const char *arg) 
+//{
+//    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+//    if (err != NULL) return err;
+//
+//    num_childs = atoi(arg);
+//    if (num_childs > server_limit) {
+//       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+//                    "WARNING: NumServers of %d exceeds ServerLimit value "
+//                    "of %d servers,", num_childs, server_limit);
+//       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+//                    " lowering NumServers to %d.  To increase, please "
+//                    "see the", server_limit);
+//       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+//                    " ServerLimit directive.");
+//       num_childs = server_limit;
+//    } 
+//    else if (num_childs < 1) 
+//    {
+//        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+//                     "WARNING: Require NumServers > 0, setting to 1");
+//        num_childs = 1;
+//    }
+//    return NULL;
+//}
+
+static const char *cf_StartThreads(cmd_parms *cmd, void *dummy,
+                                        const char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) return err;
+
+    threads_to_start = atoi(arg);
+    if (threads_to_start > thread_limit) {
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                     "WARNING: StartThreads of %d exceeds ThreadLimit value"
+                     " of %d threads,", threads_to_start,
+                     thread_limit);
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                     " lowering StartThreads to %d. To increase, please"
+                     " see the", thread_limit);
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                     " ThreadLimit directive.");
+    }
+    else if (threads_to_start < 1) {
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                     "WARNING: Require StartThreads > 0, setting to 1");
+        threads_to_start = 1;
+    }
+    return NULL;
+}
+
+static const char *cf_MinSpareThreads(cmd_parms *cmd, void *dummy,
+                                         const char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) return err;
+
+    min_spare_threads = atoi(arg);
+    if (min_spare_threads <= 0) 
+    {
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "WARNING: detected MinSpareThreads set to non-positive.");
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "Resetting to 1 to avoid almost certain Apache failure.");
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "Please read the documentation.");
+       min_spare_threads = 1;
+    }
+       
+    return NULL;
+}
+
+static const char *cf_MaxSpareThreads(cmd_parms *cmd, void *dummy,
+                                         const char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) return err;
+
+    max_spare_threads = atoi(arg);
+    if (max_spare_threads >= thread_limit) 
+    {
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "WARNING: detected MinSpareThreads set higher than");
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "ThreadLimit. Resetting to %d", thread_limit);
+       max_spare_threads = thread_limit;
+    }
+    return NULL;
+}
+
+static const char *cf_MaxThreadsPerChild(cmd_parms *cmd, void *dummy, const char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) return err;
+
+    max_threads = atoi(arg);
+    if (max_threads > thread_limit) 
+    {
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "WARNING: detected MaxThreadsPerChild set higher than");
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "ThreadLimit. Resetting to %d", thread_limit);
+       max_threads = thread_limit;
+    }
+    return NULL;
+}
+
+static const char* child_add ( int type, const char* user_name, const char* group_name ,const char* chroot_dir )
+{
+    _DBG("%d: %s.%s %s", num_childs, user_name, group_name, chroot_dir);
+    if (num_childs<server_limit)
+    {
+	int socks[2];
+        int l;
+
+        child_info_table[num_childs].uid  = ap_uname2id(user_name);
+        child_info_table[num_childs].gid  = ap_gname2id(group_name); 
+	child_info_table[num_childs].type = type;
+        socketpair(PF_UNIX, SOCK_STREAM, 0, socks);
+	child_info_table[num_childs].input  = socks[0];
+	child_info_table[num_childs].output = socks[1];
+	child_info_table[num_childs].chroot_dir = 0;
+        if (chroot_dir){
+          l = strlen(chroot_dir);
+          if (l > 0){
+            child_info_table[num_childs].chroot_dir = chroot_dir;
+            /* should copy the contents */
+            /* do we need to check its existence? */
+          }
+        }
+
+	_DBG("[%d] uid=%d gid=%d type=%d fd_in=%d fd_out=%d,chroot_dir=%s", 
+	    num_childs, 
+	    child_info_table[num_childs].uid, 
+	    child_info_table[num_childs].gid,
+	    child_info_table[num_childs].type,
+	    child_info_table[num_childs].input,
+	    child_info_table[num_childs].output,
+	    child_info_table[num_childs].chroot_dir
+	);
+	
+        if (child_info_table[num_childs].uid == 0 || 
+	    child_info_table[num_childs].gid == 0) 
+	{
+	    _DBG("Assigning root user/group to a child.",0);
+        }
+	num_childs++;
+	return NULL;
+    }
+
+    return "Trying to use more child ID's than NumServers.  "
+	   "Increase NumServers in your config file.";
+}
+    
+/* we define an Processor w/ specific uid/gid */
+static const char *cf_Processor(
+    cmd_parms *cmd, void *dummy, const char *user_name, const char *group_name, const char *chroot_dir)
+{
+    _DBG("%d: %s.%s %s", num_childs, user_name, group_name, chroot_dir);
+    return child_add ( CHILD_TYPE_PROCESSOR, user_name, group_name, chroot_dir );
+}
+
+/* we define an Multiplexer child w/ specific uid/gid */
+static const char *cf_Multiplexer(
+    cmd_parms *cmd, void *dummy, const char *user_name, const char *group_name, const char *chroot_dir)
+{
+    _DBG("%d: %s.%s %s", num_childs, user_name, group_name, chroot_dir);
+    return child_add ( CHILD_TYPE_MULTIPLEXER, user_name, group_name, chroot_dir );
+}
+
+/* process the config file option AssignUserId */
+/* -- FIXME: perhaps we could add childs from here automatically -- */
+static const char * cf_AssignUserId
+(
+    cmd_parms *cmd, 
+    void *dummy, 
+    const char *user_name,
+    const char *group_name
+)
+{
+    int i;
+    int matching = 0;
+    int uid = ap_uname2id(user_name);
+    int gid = ap_gname2id(group_name);
+    const char *errstr;
+
+    metuxmpm_server_conf *sconf 
+	= metuxmpm_SERVER_CONF(cmd->server->module_config);
+
+    sconf->fullsockname = 
+	apr_pstrcat(cmd->pool, sconf->sockname, ".", user_name,":", group_name, NULL);
+
+    _DBG("user=\"%s\" (%d) group=\"%s\" (%d) numchilds=%d", user_name, uid, group_name, gid, num_childs );
+
+    for (i = 0; i < num_childs; i++)
+    {
+	_DBG("trying %d: %d.%d / %d", i, 
+	    child_info_table[i].uid, child_info_table[i].gid, child_info_table[i].type );
+    
+        if ((uid == child_info_table[i].uid) && 
+	    (gid == child_info_table[i].gid) &&
+	    (child_info_table[i].type == CHILD_TYPE_PROCESSOR))
+	{
+	    /* create an socket for this child, if it has no one */
+	    /* FIXME: we should do it anywhere else, for _all_ childs */
+	    sconf->child  = &child_info_table[i];
+	    _DBG("assigning server to child %d; "
+		 "UID: %d, GID: %d, input=%d, output=%d", 
+		 i, uid, gid, sconf->child->input, sconf->child->output);
+	    return NULL;
+        }
+    }
+
+    _DBG("assigning server to child FAILED %d; UID: %d, GID: %d ", i, uid, gid);
+    return "Unable to find process with matching uid/gid.";
+}
+
+static const char *cf_ServerLimit (cmd_parms *cmd, void *dummy, const char *arg) 
+{
+    int tmp_server_limit;
+    
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) return err;
+
+    tmp_server_limit = atoi(arg);
+    /* you cannot change ServerLimit across a restart; ignore
+     * any such attempts
+     */
+    if (first_server_limit && tmp_server_limit != server_limit) 
+    {
+        /* how do we log a message?  the error log is a bit bucket at this
+         * point; we'll just have to set a flag so that ap_mpm_run()
+         * logs a warning later
+         */
+        changed_limit_at_restart = 1;
+        return NULL;
+    }
+    server_limit = tmp_server_limit;
+    
+    if (server_limit > MAX_SERVER_LIMIT) 
+    {
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "WARNING: ServerLimit of %d exceeds compile time limit "
+                    "of %d servers,", server_limit, MAX_SERVER_LIMIT);
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    " lowering ServerLimit to %d.", MAX_SERVER_LIMIT);
+       server_limit = MAX_SERVER_LIMIT;
+    } 
+    else if (server_limit < 1) 
+    {
+	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                     "WARNING: Require ServerLimit > 0, setting to 1");
+	server_limit = 1;
+    }
+    return NULL;
+}
+
+static const char *cf_ThreadLimit (cmd_parms *cmd, void *dummy, const char *arg) 
+{
+    int tmp_thread_limit;
+    
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) return err;
+
+    tmp_thread_limit = atoi(arg);
+    /* you cannot change ThreadLimit across a restart; ignore
+     * any such attempts
+     */
+    if (first_thread_limit && tmp_thread_limit != thread_limit) 
+    {
+        /* how do we log a message?  the error log is a bit bucket at this
+         * point; we'll just have to set a flag so that ap_mpm_run()
+         * logs a warning later
+         */
+        changed_limit_at_restart = 1;
+        return NULL;
+    }
+    thread_limit = tmp_thread_limit;
+    
+    if (thread_limit > MAX_THREAD_LIMIT) 
+    {
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "WARNING: ThreadLimit of %d exceeds compile time limit "
+                    "of %d servers,", thread_limit, MAX_THREAD_LIMIT);
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    " lowering ThreadLimit to %d.", MAX_THREAD_LIMIT);
+       thread_limit = MAX_THREAD_LIMIT;
+    } 
+    else if (thread_limit < 1) 
+    {
+	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                     "WARNING: Require ThreadLimit > 0, setting to 1");
+	thread_limit = 1;
+    }
+    return NULL;
+}
+
+static const command_rec metuxmpm_cmds[] = {
+UNIX_DAEMON_COMMANDS,
+LISTEN_COMMANDS,
+AP_INIT_TAKE1("StartThreads", cf_StartThreads, NULL, RSRC_CONF,
+              "Number of threads each child creates"),
+AP_INIT_TAKE1("MinSpareThreads", cf_MinSpareThreads, NULL, RSRC_CONF,
+              "Minimum number of idle threads per child, to handle "
+              "request spikes"),
+AP_INIT_TAKE1("MaxSpareThreads", cf_MaxSpareThreads, NULL, RSRC_CONF,
+              "Maximum number of idle threads per child"),
+AP_INIT_TAKE1("MaxThreadsPerChild", cf_MaxThreadsPerChild, NULL, RSRC_CONF,
+              "Maximum number of threads per child"),
+AP_INIT_TAKE23("Multiplexer", cf_Multiplexer, NULL, RSRC_CONF,
+              "Specify an Multiplexer Child configuration."),
+AP_INIT_TAKE23("Processor", cf_Processor, NULL, RSRC_CONF,
+              "Specify a User and Group for a specific child process."),
+AP_INIT_TAKE2("AssignUserID", cf_AssignUserId, NULL, RSRC_CONF,
+              "Tie a virtual host to a specific child process."),
+AP_INIT_TAKE1("ServerLimit", cf_ServerLimit, NULL, RSRC_CONF,
+              "Maximum value of NumServers for this run of Apache"),
+AP_INIT_TAKE1("ThreadLimit", cf_ThreadLimit, NULL, RSRC_CONF,
+              "Maximum worker threads in a server for this run of Apache"),
+{ NULL }
+};
+
+/* == allocate an private server config structure == */
+static void *metuxmpm_create_config(apr_pool_t *p, server_rec *s)
+{
+    metuxmpm_server_conf *c = (metuxmpm_server_conf *)
+                                  apr_pcalloc(p, sizeof(metuxmpm_server_conf));
+    c->child  = NULL;
+    return c;
+}
+
+module AP_MODULE_DECLARE_DATA mpm_metuxmpm_module = 
+{
+    MPM20_MODULE_STUFF,
+    ap_mpm_rewrite_args,        /* hook to run before apache parses args */
+    NULL,                       /* create per-directory config structure */
+    NULL,                       /* merge per-directory config structures */
+    metuxmpm_create_config,     /* create per-server config structure */
+    NULL,                       /* merge per-server config structures */
+    metuxmpm_cmds,              /* command apr_table_t */
+    metuxmpm_hooks              /* register_hooks */
+};
+
diff -Nur httpd-2.0.52/server/mpm/experimental/metuxmpm/mpm.h httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/mpm.h
--- httpd-2.0.52/server/mpm/experimental/metuxmpm/mpm.h	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/mpm.h	2004-10-18 15:58:44.169075112 +0200
@@ -0,0 +1,100 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" must
+ *    not be used to endorse or promote products derived from this
+ *    software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    nor may "Apache" appear in their name, without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Portions of this software are based upon public domain software
+ * originally written at the National Center for Supercomputing Applications,
+ * University of Illinois, Urbana-Champaign.
+ */
+
+#include "httpd.h"
+#include "mpm_default.h"
+#include "unixd.h"
+
+#ifndef APACHE_MPM_METUXMPM_H
+#define APACHE_MPM_METUXMPM_H
+
+#define METUXMPM_MPM
+
+#define MPM_NAME "metuxmpm"
+
+#define AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
+#define AP_MPM_WANT_WAIT_OR_TIMEOUT
+#define AP_MPM_WANT_PROCESS_CHILD_STATUS
+#define AP_MPM_WANT_SET_PIDFILE
+#define AP_MPM_WANT_SET_SCOREBOARD
+#define AP_MPM_WANT_SET_LOCKFILE
+#define AP_MPM_WANT_SET_MAX_REQUESTS
+#define AP_MPM_WANT_SET_COREDUMPDIR
+#define AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
+#define AP_MPM_WANT_SIGNAL_SERVER
+#define AP_MPM_USES_POD
+
+#define MPM_CHILD_PID(i) (ap_scoreboard_image->parent[i].pid)
+#define MPM_NOTE_CHILD_KILLED(i) (MPM_CHILD_PID(i) = 0)
+#define MPM_ACCEPT_FUNC unixd_accept
+
+/* Table of child status */
+#define SERVER_DEAD 0
+#define SERVER_DYING 1
+#define SERVER_ALIVE 2
+
+typedef struct ap_ctable{
+    pid_t pid;
+    unsigned char status;
+} ap_ctable;
+
+extern int ap_threads_per_child;
+extern int ap_max_daemons_limit;
+extern server_rec *ap_server_conf;
+
+#endif /* APACHE_MPM_METUXMPM_H */
diff -Nur httpd-2.0.52/server/mpm/experimental/metuxmpm/mpm_default.h httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/mpm_default.h
--- httpd-2.0.52/server/mpm/experimental/metuxmpm/mpm_default.h	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/metuxmpm/mpm_default.h	2004-10-18 15:58:44.170074960 +0200
@@ -0,0 +1,115 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2000-2002 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" must
+ *    not be used to endorse or promote products derived from this
+ *    software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    nor may "Apache" appear in their name, without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Portions of this software are based upon public domain software
+ * originally written at the National Center for Supercomputing Applications,
+ * University of Illinois, Urbana-Champaign.
+ */
+
+#ifndef APACHE_MPM_DEFAULT_H
+#define APACHE_MPM_DEFAULT_H
+
+#define NO_SERIALIZED_ACCEPT
+
+/* Number of threads to spawn off by default --- also, if fewer than
+ * this free when the caretaker checks, it will spawn more.
+ */
+#ifndef DEFAULT_START_THREAD
+#define DEFAULT_START_THREAD 5
+#endif
+
+/* Maximum number of *free* server threads --- more than this, and
+ * they will die off.
+ */
+
+#ifndef DEFAULT_MAX_SPARE_THREAD
+#define DEFAULT_MAX_SPARE_THREAD 10
+#endif
+
+/* Minimum --- fewer than this, and more will be created */
+
+#ifndef DEFAULT_MIN_SPARE_THREAD
+#define DEFAULT_MIN_SPARE_THREAD 5
+#endif
+
+/* Number of servers to spawn off by default
+ */
+#ifndef DEFAULT_NUM_DAEMON
+#define DEFAULT_NUM_DAEMON 2
+#endif
+
+/* File used for accept locking, when we use a file */
+#ifndef DEFAULT_LOCKFILE
+#define DEFAULT_LOCKFILE DEFAULT_REL_RUNTIMEDIR "/accept.lock"
+#endif
+
+/* Where the main/parent process's pid is logged */
+#ifndef DEFAULT_PIDLOG
+#define DEFAULT_PIDLOG DEFAULT_REL_RUNTIMEDIR "/httpd.pid"
+#endif
+
+/*
+ * Interval, in microseconds, between scoreboard maintenance.
+ */
+#ifndef SCOREBOARD_MAINTENANCE_INTERVAL
+#define SCOREBOARD_MAINTENANCE_INTERVAL 1000000
+#endif
+
+/* Number of requests to try to handle in a single process.  If <= 0,
+ * the children don't die off.
+ */
+#ifndef DEFAULT_MAX_REQUESTS_PER_CHILD
+#define DEFAULT_MAX_REQUESTS_PER_CHILD 10000
+#endif
+
+#endif /* AP_MPM_DEFAULT_H */
diff -Nur httpd-2.0.52/server/mpm/experimental/peruser/Makefile.in httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/Makefile.in
--- httpd-2.0.52/server/mpm/experimental/peruser/Makefile.in	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/Makefile.in	2004-10-18 15:58:50.836061576 +0200
@@ -0,0 +1,5 @@
+
+LTLIBRARY_NAME    = libperuser.la
+LTLIBRARY_SOURCES = peruser.c
+
+include $(top_srcdir)/build/ltlib.mk
diff -Nur httpd-2.0.52/server/mpm/experimental/peruser/config.m4 httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/config.m4
--- httpd-2.0.52/server/mpm/experimental/peruser/config.m4	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/config.m4	2004-10-18 15:58:50.835061728 +0200
@@ -0,0 +1,3 @@
+if test "$MPM_NAME" = "peruser" ; then
+    APACHE_FAST_OUTPUT(server/mpm/experimental/$MPM_NAME/Makefile)
+fi
diff -Nur httpd-2.0.52/server/mpm/experimental/peruser/mpm.h httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/mpm.h
--- httpd-2.0.52/server/mpm/experimental/peruser/mpm.h	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/mpm.h	2004-10-18 15:58:50.838061272 +0200
@@ -0,0 +1,103 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" must
+ *    not be used to endorse or promote products derived from this
+ *    software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    nor may "Apache" appear in their name, without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Portions of this software are based upon public domain software
+ * originally written at the National Center for Supercomputing Applications,
+ * University of Illinois, Urbana-Champaign.
+ */
+
+#include "httpd.h"
+#include "mpm_default.h"
+#include "scoreboard.h"
+#include "unixd.h"
+
+#ifndef APACHE_MPM_PERUSER_H
+#define APACHE_MPM_PERUSER_H
+
+#define PERUSER_MPM
+
+#define MPM_NAME "Peruser"
+
+#define AP_MPM_WANT_RECLAIM_CHILD_PROCESSES
+#define AP_MPM_WANT_WAIT_OR_TIMEOUT
+#define AP_MPM_WANT_PROCESS_CHILD_STATUS
+#define AP_MPM_WANT_SET_PIDFILE
+#define AP_MPM_WANT_SET_SCOREBOARD
+#define AP_MPM_WANT_SET_LOCKFILE
+#define AP_MPM_WANT_SET_MAX_REQUESTS
+#define AP_MPM_WANT_SET_COREDUMPDIR
+#define AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
+#define AP_MPM_WANT_SIGNAL_SERVER
+#define AP_MPM_WANT_SET_MAX_MEM_FREE
+#define AP_MPM_DISABLE_NAGLE_ACCEPTED_SOCK
+
+#define AP_MPM_USES_POD 1
+#define MPM_CHILD_PID(i) (ap_scoreboard_image->parent[i].pid)
+#define MPM_NOTE_CHILD_KILLED(i) (MPM_CHILD_PID(i) = 0)
+#define MPM_ACCEPT_FUNC unixd_accept
+
+extern int ap_threads_per_child;
+extern int ap_max_daemons_limit;
+extern server_rec *ap_server_conf;
+
+/* Table of child status */
+#define SERVER_DEAD 0
+#define SERVER_DYING 1
+#define SERVER_ALIVE 2
+
+typedef struct ap_ctable {
+    pid_t pid;
+    unsigned char status;
+} ap_ctable;
+
+#endif /* APACHE_MPM_PERUSER_H */
diff -Nur httpd-2.0.52/server/mpm/experimental/peruser/mpm_default.h httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/mpm_default.h
--- httpd-2.0.52/server/mpm/experimental/peruser/mpm_default.h	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/mpm_default.h	2004-10-18 15:58:50.837061424 +0200
@@ -0,0 +1,113 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" must
+ *    not be used to endorse or promote products derived from this
+ *    software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    nor may "Apache" appear in their name, without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Portions of this software are based upon public domain software
+ * originally written at the National Center for Supercomputing Applications,
+ * University of Illinois, Urbana-Champaign.
+ */
+
+#ifndef APACHE_MPM_DEFAULT_H
+#define APACHE_MPM_DEFAULT_H
+
+/* Number of servers to spawn off by default --- also, if fewer than
+ * this free when the caretaker checks, it will spawn more.
+ */
+#ifndef DEFAULT_START_DAEMON
+#define DEFAULT_START_DAEMON 5
+#endif
+
+/* Maximum number of *free* server processes --- more than this, and
+ * they will die off.
+ */
+
+#ifndef DEFAULT_MAX_FREE_DAEMON
+#define DEFAULT_MAX_FREE_DAEMON 10
+#endif
+
+/* Minimum --- fewer than this, and more will be created */
+
+#ifndef DEFAULT_MIN_FREE_DAEMON
+#define DEFAULT_MIN_FREE_DAEMON 5
+#endif
+
+/* Maximum processors per ServerEnvironment */
+
+#ifndef DEFAULT_MAX_PROCESSORS
+#define DEFAULT_MAX_PROCESSORS 10
+#endif
+
+/* File used for accept locking, when we use a file */
+#ifndef DEFAULT_LOCKFILE
+#define DEFAULT_LOCKFILE DEFAULT_REL_RUNTIMEDIR "/accept.lock"
+#endif
+
+/* Where the main/parent process's pid is logged */
+#ifndef DEFAULT_PIDLOG
+#define DEFAULT_PIDLOG DEFAULT_REL_RUNTIMEDIR "/httpd.pid"
+#endif
+
+/*
+ * Interval, in microseconds, between scoreboard maintenance.
+ */
+#ifndef SCOREBOARD_MAINTENANCE_INTERVAL
+#define SCOREBOARD_MAINTENANCE_INTERVAL 1000000
+#endif
+
+/* Number of requests to try to handle in a single process.  If <= 0,
+ * the children don't die off.
+ */
+#ifndef DEFAULT_MAX_REQUESTS_PER_CHILD
+#define DEFAULT_MAX_REQUESTS_PER_CHILD 10000
+#endif
+
+#endif /* AP_MPM_DEFAULT_H */
diff -Nur httpd-2.0.52/server/mpm/experimental/peruser/peruser.c httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/peruser.c
--- httpd-2.0.52/server/mpm/experimental/peruser/peruser.c	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/server/mpm/experimental/peruser/peruser.c	2004-10-18 15:58:50.853058992 +0200
@@ -0,0 +1,2620 @@
+/* ====================================================================
+ * The Apache Software License, Version 1.1
+ *
+ * Copyright (c) 2000-2003 The Apache Software Foundation.  All rights
+ * reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. The end-user documentation included with the redistribution,
+ *    if any, must include the following acknowledgment:
+ *       "This product includes software developed by the
+ *        Apache Software Foundation (http://www.apache.org/)."
+ *    Alternately, this acknowledgment may appear in the software itself,
+ *    if and wherever such third-party acknowledgments normally appear.
+ *
+ * 4. The names "Apache" and "Apache Software Foundation" must
+ *    not be used to endorse or promote products derived from this
+ *    software without prior written permission. For written
+ *    permission, please contact apache@apache.org.
+ *
+ * 5. Products derived from this software may not be called "Apache",
+ *    nor may "Apache" appear in their name, without prior written
+ *    permission of the Apache Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
+ * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This software consists of voluntary contributions made by many
+ * individuals on behalf of the Apache Software Foundation.  For more
+ * information on the Apache Software Foundation, please see
+ * <http://www.apache.org/>.
+ *
+ * Portions of this software are based upon public domain software
+ * originally written at the National Center for Supercomputing Applications,
+ * University of Illinois, Urbana-Champaign.
+ */
+
+/* #define MPM_PERUSER_DEBUG */
+
+#include "apr.h"
+#include "apr_hash.h"
+#include "apr_pools.h"
+#include "apr_file_io.h"
+#include "apr_portable.h"
+#include "apr_strings.h"
+#include "apr_thread_proc.h"
+#include "apr_signal.h"
+
+#define APR_WANT_STDIO
+#define APR_WANT_STRFUNC
+#define APR_WANT_IOVEC
+#include "apr_want.h"
+
+#if APR_HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if APR_HAVE_SYS_TYPES_H
+#include <sys/types.h>
+#endif
+
+#define CORE_PRIVATE
+
+#include "ap_config.h"
+#include "httpd.h"
+#include "mpm_default.h"
+#include "http_main.h"
+#include "http_log.h"
+#include "http_config.h"
+#include "http_core.h"		/* for get_remote_host */
+#include "http_connection.h"
+#include "http_protocol.h"  /* for ap_hook_post_read_request */
+#include "scoreboard.h"
+#include "ap_mpm.h"
+#include "unixd.h"
+#include "mpm_common.h"
+#include "ap_listen.h"
+#include "ap_mmn.h"
+#include "apr_poll.h"
+#include "util_ebcdic.h"
+
+#ifdef HAVE_BSTRING_H
+#include <bstring.h>		/* for IRIX, FD_SET calls bzero() */
+#endif
+
+#ifdef HAVE_TIME_H
+#include <time.h>
+#endif
+
+#ifdef HAVE_SYS_PROCESSOR_H
+#include <sys/processor.h> /* for bindprocessor() */
+#endif
+
+#if APR_HAS_SHARED_MEMORY
+#include "apr_shm.h"
+#else
+#error "Peruser MPM requres shared memory support."
+#endif
+
+
+/* should be APR-ized */
+#include <grp.h>
+#include <pwd.h>
+#include <sys/stat.h>
+#include <sys/un.h>
+#include <setjmp.h>
+
+#include <signal.h>
+#include <sys/times.h>
+
+
+#ifdef MPM_PERUSER_DEBUG
+# define _DBG(text,par...) \
+    ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL, \
+                 "(peruser: pid=%d uid=%d child=%d) %s(): " text, \
+                 getpid(), getuid(), my_child_num, __FUNCTION__, ##par, 0)
+
+# define _TRACE_CALL(text,par...) _DBG("calling " text, ##par)
+# define _TRACE_RET(text,par...) _DBG("returned from " text, ##par)
+#else
+# define _DBG(text,par...)
+# define _TRACE_RET(text,par...)
+# define _TRACE_CALL(text,par...)
+#endif /* MPM_PERUSER_DEBUG */
+
+/* char of death - for signalling children to die */
+#define AP_PERUSER_CHAR_OF_DEATH        '!'
+
+#define PERUSER_SERVER_CONF(cf)        \
+    ((peruser_server_conf *) ap_get_module_config(cf, &mpm_peruser_module))
+
+/*
+ * Define some magic numbers that we use for the state of the incomming
+ * request. These must be < 0 so they don't collide with a file descriptor.
+ */
+#define AP_PERUSER_THISCHILD -1
+#define AP_PERUSER_OTHERCHILD -2
+
+
+/* Limit on the total --- clients will be locked out if more servers than
+ * this are needed.  It is intended solely to keep the server from crashing
+ * when things get out of hand.
+ *
+ * We keep a hard maximum number of servers, for two reasons --- first off,
+ * in case something goes seriously wrong, we want to stop the fork bomb
+ * short of actually crashing the machine we're running on by filling some
+ * kernel table.  Secondly, it keeps the size of the scoreboard file small
+ * enough that we can read the whole thing without worrying too much about
+ * the overhead.
+ */
+#ifndef DEFAULT_SERVER_LIMIT
+#define DEFAULT_SERVER_LIMIT 256
+#endif
+
+/* Admin can't tune ServerLimit beyond MAX_SERVER_LIMIT.  We want
+ * some sort of compile-time limit to help catch typos.
+ */
+#ifndef MAX_SERVER_LIMIT
+#define MAX_SERVER_LIMIT 20000
+#endif
+
+#ifndef HARD_THREAD_LIMIT
+#define HARD_THREAD_LIMIT 1
+#endif
+
+#define CHILD_TYPE_MULTIPLEXER  1
+#define CHILD_TYPE_PROCESSOR    2
+
+#define CHILD_STATUS_STANDBY  0  /* wait for a request before starting */
+#define CHILD_STATUS_STARTING 1  /* wait for socket creation */
+#define CHILD_STATUS_READY    2  /* wait for mux to restart */
+#define CHILD_STATUS_ACTIVE   3  /* ready to take requests */
+#define CHILD_STATUS_RESTART  4  /* child about to die and restart */
+
+/* config globals */
+
+int ap_threads_per_child=0;         /* Worker threads per child */
+static apr_proc_mutex_t *accept_mutex;
+static int ap_daemons_min_free=0;
+static int ap_max_processors=0;
+static int ap_daemons_limit=0;      /* MaxClients */
+static int server_limit = DEFAULT_SERVER_LIMIT;
+static int first_server_limit;
+static int changed_limit_at_restart;
+
+static int requests_this_child;
+static ap_pod_t *pod;
+
+/* === configuration stuff === */
+
+/* -- server process information -- */
+typedef struct
+{
+    /* identification */
+    int id;		/* index in child_info_table */
+    pid_t pid;		/* process id */
+    int status;		/* status of child */
+    int type;           /* multiplexer or processor */
+
+    /* security settings */
+    uid_t uid;		/* user id */
+    gid_t gid;		/* group id */
+    const char *chroot;	/* directory to chroot() to, can be null */
+
+    /* sockets */
+    int input;		/* The socket descriptor */
+    int output;		/* The socket descriptor */
+    int sock_fd;
+
+    /* stack context saved state */
+    jmp_buf jmpbuffer;
+} child_info_t;
+
+typedef struct
+{
+    apr_size_t num_childs;
+} child_info_control;
+
+typedef struct
+{
+    child_info_control *control;
+    child_info_t *table;
+} child_info;
+
+typedef struct
+{
+    const char *sockname;       /* The base name for the socket */
+    const char *fullsockname;   /* socket base name + extension */
+    uid_t uid;
+    gid_t gid;
+    const char *chroot;
+    int max_processors;
+    int last_child;
+} peruser_server_conf;
+
+typedef struct peruser_header
+{
+    char *headers;
+    apr_pool_t *p;
+} peruser_header;
+
+
+/* Tables used to determine the user and group each child process should
+ * run as.  The hash table is used to correlate a server name with a child
+ * process.
+ */
+static apr_size_t child_info_size;
+static child_info *child_info_image;
+struct ap_ctable *ap_child_table;
+
+#define NUM_CHILDS (child_info_image != NULL ? child_info_image->control->num_childs : 0)
+#define CHILD_INFO_TABLE (child_info_image != NULL ? child_info_image->table : NULL)
+
+#if APR_HAS_SHARED_MEMORY
+#ifndef WIN32
+static /* but must be exported to mpm_winnt */
+#endif
+        apr_shm_t *child_info_shm = NULL;
+#endif
+
+/*
+ * The max child slot ever assigned, preserved across restarts.  Necessary
+ * to deal with MaxClients changes across AP_SIG_GRACEFUL restarts.  We 
+ * use this value to optimize routines that have to scan the entire scoreboard.
+ */
+int ap_max_daemons_limit = -1;
+server_rec *ap_server_conf;
+
+module AP_MODULE_DECLARE_DATA mpm_peruser_module;
+
+/* -- replace the pipe-of-death by an control socket -- */
+static apr_file_t *pipe_of_death_in = NULL;
+static apr_file_t *pipe_of_death_out = NULL;
+
+
+/* one_process --- debugging mode variable; can be set from the command line
+ * with the -X flag.  If set, this gets you the child_main loop running
+ * in the process which originally started up (no detach, no make_child),
+ * which is a pretty nice debugging environment.  (You'll get a SIGHUP
+ * early in standalone_main; just continue through.  This is the server
+ * trying to kill off any child processes which it might have lying
+ * around --- Apache doesn't keep track of their pids, it just sends
+ * SIGHUP to the process group, ignoring it in the root process.
+ * Continue through and you'll be fine.).
+ */
+
+static int one_process = 0;
+
+static apr_pool_t *pconf;		/* Pool for config stuff */
+static apr_pool_t *pchild;		/* Pool for httpd child stuff */
+
+static pid_t ap_my_pid;	/* it seems silly to call getpid all the time */
+static pid_t parent_pid;
+static int my_child_num;
+ap_generation_t volatile ap_my_generation=0;
+
+#ifdef TPF
+int tpf_child = 0;
+char tpf_server_name[INETD_SERVNAME_LENGTH+1];
+#endif /* TPF */
+
+static int die_now = 0;
+
+#ifdef GPROF
+/* 
+ * change directory for gprof to plop the gmon.out file
+ * configure in httpd.conf:
+ * GprofDir $RuntimeDir/   -> $ServerRoot/$RuntimeDir/gmon.out
+ * GprofDir $RuntimeDir/%  -> $ServerRoot/$RuntimeDir/gprof.$pid/gmon.out
+ */
+static void chdir_for_gprof(void)
+{
+    core_server_config *sconf = 
+	ap_get_module_config(ap_server_conf->module_config, &core_module);    
+    char *dir = sconf->gprof_dir;
+    const char *use_dir;
+
+    if(dir) {
+        apr_status_t res;
+	char buf[512];
+	int len = strlen(sconf->gprof_dir) - 1;
+	if(*(dir + len) == '%') {
+	    dir[len] = '\0';
+	    apr_snprintf(buf, sizeof(buf), "%sgprof.%d", dir, (int)getpid());
+	} 
+	use_dir = ap_server_root_relative(pconf, buf[0] ? buf : dir);
+	res = apr_dir_make(use_dir, 0755, pconf);
+	if(res != APR_SUCCESS && !APR_STATUS_IS_EEXIST(res)) {
+	    ap_log_error(APLOG_MARK, APLOG_ERR, errno, ap_server_conf,
+			 "gprof: error creating directory %s", dir);
+	}
+    }
+    else {
+	use_dir = ap_server_root_relative(pconf, DEFAULT_REL_RUNTIMEDIR);
+    }
+
+    chdir(use_dir);
+}
+#else
+#define chdir_for_gprof()
+#endif
+
+char* child_type_string(int type)
+{
+    switch(type)
+    {
+        case CHILD_TYPE_MULTIPLEXER: return "MULTIPLEXER";
+        case CHILD_TYPE_PROCESSOR:   return "PROCESSOR";
+    }
+
+    return "UNKNOWN";
+}
+
+char* child_status_string(int status)
+{
+    switch(status)
+    {
+        case CHILD_STATUS_STANDBY:  return "STANDBY";
+        case CHILD_STATUS_STARTING: return "STARTING";
+        case CHILD_STATUS_READY:    return "READY";
+        case CHILD_STATUS_ACTIVE:   return "ACTIVE";
+        case CHILD_STATUS_RESTART:  return "RESTART";
+    }
+
+    return "UNKNOWN";
+}
+
+void dump_child_table()
+{
+  int x;
+
+  _DBG("%-3s %-5s %-8s %-12s %-4s %-4s %-25s %5s %6s %7s",
+    "ID", "PID", "STATUS", "TYPE", "UID", "GID", "CHROOT", "INPUT", "OUTPUT", "SOCK_FD");
+
+  for(x = 0; x < NUM_CHILDS; x++)
+  {
+    _DBG("%-3d %-5d %-8s %-12s %-4d %-4d %-25s %-5d %-6d %-7d",
+      CHILD_INFO_TABLE[x].id,
+      CHILD_INFO_TABLE[x].pid,
+      child_status_string(CHILD_INFO_TABLE[x].status),
+      child_type_string(CHILD_INFO_TABLE[x].type),
+      CHILD_INFO_TABLE[x].uid,
+      CHILD_INFO_TABLE[x].gid,
+      CHILD_INFO_TABLE[x].chroot,
+      CHILD_INFO_TABLE[x].input,
+      CHILD_INFO_TABLE[x].output,
+      CHILD_INFO_TABLE[x].sock_fd);
+  }
+}
+
+/* XXX - I don't know if TPF will ever use this module or not, so leave
+ * the ap_check_signals calls in but disable them - manoj */
+#define ap_check_signals() 
+
+/* a clean exit from a child with proper cleanup */
+static inline int clean_child_exit(int code) __attribute__ ((noreturn));
+static inline int clean_child_exit(int code)
+{
+    if (pchild) {
+	apr_pool_destroy(pchild);
+    }
+    ap_mpm_pod_close(pod);
+    chdir_for_gprof();
+    exit(code);
+}
+
+static void accept_mutex_on(void)
+{
+/* for some reason this fails if we listen on the pipe_of_death.
+   fortunately I don't think we currently need it */
+
+#if 0
+    apr_status_t rv = apr_proc_mutex_lock(accept_mutex);
+    if (rv != APR_SUCCESS) {
+        const char *msg = "couldn't grab the accept mutex";
+
+        if (ap_my_generation != 
+            ap_scoreboard_image->global->running_generation) {
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, NULL, msg);
+            clean_child_exit(0);
+        }
+        else {
+            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, NULL, msg);
+            exit(APEXIT_CHILDFATAL);
+        }
+    }
+#endif
+}
+
+static void accept_mutex_off(void)
+{
+#if 0
+    apr_status_t rv = apr_proc_mutex_unlock(accept_mutex);
+    if (rv != APR_SUCCESS) {
+        const char *msg = "couldn't release the accept mutex";
+
+        if (ap_my_generation != 
+            ap_scoreboard_image->global->running_generation) {
+            ap_log_error(APLOG_MARK, APLOG_DEBUG, rv, NULL, msg);
+            /* don't exit here... we have a connection to
+             * process, after which point we'll see that the
+             * generation changed and we'll exit cleanly
+             */
+        }
+        else {
+            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, NULL, msg);
+            exit(APEXIT_CHILDFATAL);
+        }
+    }
+#endif
+}
+
+/* On some architectures it's safe to do unserialized accept()s in the single
+ * Listen case.  But it's never safe to do it in the case where there's
+ * multiple Listen statements.  Define SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+ * when it's safe in the single Listen case.
+ */
+#ifdef SINGLE_LISTEN_UNSERIALIZED_ACCEPT
+#define SAFE_ACCEPT(stmt) do {if (ap_listeners->next) {stmt;}} while(0)
+#else
+#define SAFE_ACCEPT(stmt) do {stmt;} while(0)
+#endif
+
+AP_DECLARE(apr_status_t) ap_mpm_query(int query_code, int *result)
+{
+    switch(query_code){
+        case AP_MPMQ_MAX_DAEMON_USED:
+            *result = ap_daemons_limit;
+            return APR_SUCCESS;
+        case AP_MPMQ_IS_THREADED:
+            *result = AP_MPMQ_NOT_SUPPORTED;
+            return APR_SUCCESS;
+        case AP_MPMQ_IS_FORKED:
+            *result = AP_MPMQ_DYNAMIC;
+            return APR_SUCCESS;
+        case AP_MPMQ_HARD_LIMIT_DAEMONS:
+            *result = server_limit;
+            return APR_SUCCESS;
+        case AP_MPMQ_HARD_LIMIT_THREADS:
+            *result = HARD_THREAD_LIMIT;
+            return APR_SUCCESS;
+        case AP_MPMQ_MAX_THREADS:
+            *result = 0;
+            return APR_SUCCESS;
+        case AP_MPMQ_MIN_SPARE_DAEMONS:
+            *result = ap_daemons_min_free;
+            return APR_SUCCESS;
+        case AP_MPMQ_MIN_SPARE_THREADS:
+            *result = 0;
+            return APR_SUCCESS;
+        case AP_MPMQ_MAX_SPARE_THREADS:
+            *result = 0;
+            return APR_SUCCESS;
+        case AP_MPMQ_MAX_REQUESTS_DAEMON:
+            *result = ap_max_requests_per_child;
+            return APR_SUCCESS;
+        case AP_MPMQ_MAX_DAEMONS:
+            *result = server_limit;
+            return APR_SUCCESS;
+    }
+    return APR_ENOTIMPL;
+}
+
+#if defined(NEED_WAITPID)
+/*
+   Systems without a real waitpid sometimes lose a child's exit while waiting
+   for another.  Search through the scoreboard for missing children.
+ */
+int reap_children(int *exitcode, apr_exit_why_e *status)
+{
+    int n, pid;
+
+    for (n = 0; n < ap_max_daemons_limit; ++n) {
+	if (ap_scoreboard_image->servers[n][0].status != SERVER_DEAD &&
+		kill((pid = ap_scoreboard_image->parent[n].pid), 0) == -1) {
+	    ap_update_child_status_from_indexes(n, 0, SERVER_DEAD, NULL);
+	    /* just mark it as having a successful exit status */
+            *status = APR_PROC_EXIT;
+            *exitcode = 0;
+	    return(pid);
+	}
+    }
+    return 0;
+}
+#endif
+
+/* handle all varieties of core dumping signals */
+static void sig_coredump(int sig)
+{
+    chdir(ap_coredump_dir);
+    apr_signal(sig, SIG_DFL);
+    if (ap_my_pid == parent_pid) {
+            ap_log_error(APLOG_MARK, APLOG_NOTICE,
+                         0, ap_server_conf,
+                         "seg fault or similar nasty error detected "
+                         "in the parent process");
+    }
+    kill(getpid(), sig);
+    /* At this point we've got sig blocked, because we're still inside
+     * the signal handler.  When we leave the signal handler it will
+     * be unblocked, and we'll take the signal... and coredump or whatever
+     * is appropriate for this particular Unix.  In addition the parent
+     * will see the real signal we received -- whereas if we called
+     * abort() here, the parent would only see SIGABRT.
+     */
+}
+
+/*****************************************************************
+ * Connection structures and accounting...
+ */
+
+static void just_die(int sig)
+{
+_DBG("function called");
+    clean_child_exit(0);
+}
+
+/* volatile just in case */
+static int volatile shutdown_pending;
+static int volatile restart_pending;
+static int volatile is_graceful;
+/* XXX static int volatile child_fatal; */
+
+static void sig_term(int sig)
+{
+    if (shutdown_pending == 1) {
+	/* Um, is this _probably_ not an error, if the user has
+	 * tried to do a shutdown twice quickly, so we won't
+	 * worry about reporting it.
+	 */
+	return;
+    }
+    shutdown_pending = 1;
+}
+
+/* restart() is the signal handler for SIGHUP and AP_SIG_GRACEFUL
+ * in the parent process, unless running in ONE_PROCESS mode
+ */
+static void restart(int sig)
+{
+    if (restart_pending == 1) {
+	/* Probably not an error - don't bother reporting it */
+	return;
+    }
+    restart_pending = 1;
+    is_graceful = (sig == AP_SIG_GRACEFUL);
+}
+
+/* Sets die_now if we received a character on the pipe_of_death */
+static apr_status_t check_pipe_of_death
+(
+    void **csd,
+    ap_listen_rec *lr,
+    apr_pool_t *ptrans
+)
+{
+    int ret;
+    char pipe_read_char;
+    apr_size_t n = 1;
+
+    _DBG("WATCH: die_now=%d", die_now);
+
+    if (die_now) return APR_SUCCESS;
+
+    /* apr_thread_mutex_lock(pipe_of_death_mutex); */
+    ret = apr_recv(lr->sd, &pipe_read_char, &n);
+    if (APR_STATUS_IS_EAGAIN(ret))
+    {
+            /* It lost the lottery. It must continue to suffer
+             * through a life of servitude. */
+    }
+    else
+    {
+       if (pipe_read_char != AP_PERUSER_CHAR_OF_DEATH)
+       {
+           _DBG("got wrong char %c", pipe_read_char);
+           return APR_SUCCESS;
+       }
+        /* It won the lottery (or something else is very
+         * wrong). Embrace death with open arms. */
+        die_now = 1;
+        _DBG("WATCH: die_now=%d", die_now);
+    }
+    /* apr_thread_mutex_unlock(pipe_of_death_mutex); */
+    return APR_SUCCESS;
+}
+
+static void set_signals(void)
+{
+#ifndef NO_USE_SIGACTION
+    struct sigaction sa;
+
+    sigemptyset(&sa.sa_mask);
+    sa.sa_flags = 0;
+
+    if (!one_process) {
+	sa.sa_handler = sig_coredump;
+#if defined(SA_ONESHOT)
+	sa.sa_flags = SA_ONESHOT;
+#elif defined(SA_RESETHAND)
+	sa.sa_flags = SA_RESETHAND;
+#endif
+	if (sigaction(SIGSEGV, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGSEGV)");
+#ifdef SIGBUS
+	if (sigaction(SIGBUS, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGBUS)");
+#endif
+#ifdef SIGABORT
+	if (sigaction(SIGABORT, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGABORT)");
+#endif
+#ifdef SIGABRT
+	if (sigaction(SIGABRT, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGABRT)");
+#endif
+#ifdef SIGILL
+	if (sigaction(SIGILL, &sa, NULL) < 0)
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGILL)");
+#endif
+	sa.sa_flags = 0;
+    }
+    sa.sa_handler = sig_term;
+    if (sigaction(SIGTERM, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGTERM)");
+#ifdef SIGINT
+    if (sigaction(SIGINT, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGINT)");
+#endif
+#ifdef SIGXCPU
+    sa.sa_handler = SIG_DFL;
+    if (sigaction(SIGXCPU, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGXCPU)");
+#endif
+#ifdef SIGXFSZ
+    sa.sa_handler = SIG_IGN;
+    if (sigaction(SIGXFSZ, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGXFSZ)");
+#endif
+#ifdef SIGPIPE
+    sa.sa_handler = SIG_IGN;
+    if (sigaction(SIGPIPE, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGPIPE)");
+#endif
+
+    /* we want to ignore HUPs and AP_SIG_GRACEFUL while we're busy 
+     * processing one */
+    sigaddset(&sa.sa_mask, SIGHUP);
+    sigaddset(&sa.sa_mask, AP_SIG_GRACEFUL);
+    sa.sa_handler = restart;
+    if (sigaction(SIGHUP, &sa, NULL) < 0)
+	ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(SIGHUP)");
+    if (sigaction(AP_SIG_GRACEFUL, &sa, NULL) < 0)
+        ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "sigaction(" AP_SIG_GRACEFUL_STRING ")");
+#else
+    if (!one_process) {
+	apr_signal(SIGSEGV, sig_coredump);
+#ifdef SIGBUS
+	apr_signal(SIGBUS, sig_coredump);
+#endif /* SIGBUS */
+#ifdef SIGABORT
+	apr_signal(SIGABORT, sig_coredump);
+#endif /* SIGABORT */
+#ifdef SIGABRT
+	apr_signal(SIGABRT, sig_coredump);
+#endif /* SIGABRT */
+#ifdef SIGILL
+	apr_signal(SIGILL, sig_coredump);
+#endif /* SIGILL */
+#ifdef SIGXCPU
+	apr_signal(SIGXCPU, SIG_DFL);
+#endif /* SIGXCPU */
+#ifdef SIGXFSZ
+	apr_signal(SIGXFSZ, SIG_DFL);
+#endif /* SIGXFSZ */
+    }
+
+    apr_signal(SIGTERM, sig_term);
+#ifdef SIGHUP
+    apr_signal(SIGHUP, restart);
+#endif /* SIGHUP */
+#ifdef AP_SIG_GRACEFUL
+    apr_signal(AP_SIG_GRACEFUL, restart);
+#endif /* AP_SIG_GRACEFUL */
+#ifdef SIGPIPE
+    apr_signal(SIGPIPE, SIG_IGN);
+#endif /* SIGPIPE */
+
+#endif
+}
+
+/*****************************************************************
+ * Child process main loop.
+ * The following vars are static to avoid getting clobbered by longjmp();
+ * they are really private to child_main.
+ */
+
+static int requests_this_child;
+static int num_listensocks = 0;
+static ap_listen_rec *listensocks;
+
+int ap_graceful_stop_signalled(void)
+{
+    /* not ever called anymore... */
+    return 0;
+}
+
+static void process_socket(apr_pool_t *p, apr_socket_t *sock, long conn_id,
+                           apr_bucket_alloc_t *bucket_alloc)
+{
+    conn_rec *current_conn;
+    int sock_fd;
+    apr_status_t rv;
+    ap_sb_handle_t *sbh;
+
+    if ((rv = apr_os_sock_get(&sock_fd, sock)) != APR_SUCCESS)
+    {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv, NULL, "apr_os_sock_get");
+    }
+
+    _DBG("child_num=%d sock=%ld sock_fd=%d\n", my_child_num, sock, sock_fd);
+
+    switch (CHILD_INFO_TABLE[my_child_num].type)
+    {
+        case CHILD_TYPE_MULTIPLEXER:
+            _DBG("type=MULTIPLEXER %d", my_child_num);
+            break;
+        case CHILD_TYPE_PROCESSOR:
+            _DBG("type=PROCESSOR %d", my_child_num);
+            break;
+        default:
+            _DBG("type UNKNOWN! %d", my_child_num);
+    }
+
+    if (sock_fd >= FD_SETSIZE)
+    {
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, NULL,
+                     "new file descriptor %d is too large; you probably need "
+                     "to rebuild Apache with a larger FD_SETSIZE "
+                     "(currently %d)",
+                     sock_fd, FD_SETSIZE);
+        apr_socket_close(sock);
+        _DBG("child_num=%d: exiting with error", my_child_num);
+        return;
+    }
+
+    if (CHILD_INFO_TABLE[my_child_num].sock_fd < 0)
+    {
+        ap_sock_disable_nagle(sock);
+    }
+
+    ap_create_sb_handle(&sbh, p, conn_id, 0);
+    current_conn = ap_run_create_connection(p, ap_server_conf, sock, conn_id,
+                                            sbh, bucket_alloc);
+
+    if (current_conn)
+    {
+        ap_process_connection(current_conn, sock);
+        ap_lingering_close(current_conn);
+    }
+}
+
+static int peruser_process_connection(conn_rec *conn)
+{
+    ap_filter_t *filter;
+    apr_bucket_brigade *bb;
+    core_net_rec *net;
+
+    _DBG("function entered",0);
+
+    /* -- fetch our sockets from the pool -- */
+    apr_pool_userdata_get((void **)&bb, "PERUSER_SOCKETS", conn->pool);
+    if (bb != NULL)
+    {
+        /* -- find the 'core' filter and give the socket data to it -- */
+        for (filter = conn->output_filters; filter != NULL; filter = filter->next)
+        {
+            if (!strcmp(filter->frec->name, "core")) break;
+        }
+        if (filter != NULL)
+        {
+            net = filter->ctx;
+            net->in_ctx = apr_palloc(conn->pool, sizeof(*net->in_ctx));
+            net->in_ctx->b = bb;
+        }
+    }
+    _DBG("leaving (DECLINED)", 0);
+    return DECLINED;
+}
+
+static int total_processors(peruser_server_conf* sconf)
+{
+    int i, total;
+
+    for(i = 0, total = 0; i < NUM_CHILDS; ++i)
+    {
+        if(CHILD_INFO_TABLE[i].uid == sconf->uid &&
+           CHILD_INFO_TABLE[i].gid == sconf->gid &&
+           (!sconf->chroot || !strcmp(CHILD_INFO_TABLE[i].chroot, sconf->chroot)))
+        {
+            total++;
+        }
+    }
+
+    return total;
+}
+
+static int idle_processors(peruser_server_conf* sconf)
+{
+    int i, total;
+
+    for(i = 0, total = 0; i < NUM_CHILDS; ++i)
+    {
+        if(CHILD_INFO_TABLE[i].uid == sconf->uid &&
+           CHILD_INFO_TABLE[i].gid == sconf->gid &&
+           (!sconf->chroot || !strcmp(CHILD_INFO_TABLE[i].chroot, sconf->chroot)) &&
+           ap_scoreboard_image->servers[i][0].status == SERVER_READY)
+        {
+            total++;
+        }
+    }
+
+    return total;
+}
+
+static child_info_t* find_next_multiplexer()
+{
+    int i;
+
+    _DBG("function entered", 0);
+
+    for(i = 0; i < NUM_CHILDS; ++i)
+    {
+        if(CHILD_INFO_TABLE[i].type == CHILD_TYPE_MULTIPLEXER)
+            return &CHILD_INFO_TABLE[i];
+    }
+
+    return NULL;
+}
+
+static child_info_t* find_next_processor(peruser_server_conf* sconf)
+{
+    int i, match;
+
+    _DBG("function entered", 0);
+    _DBG("uid=%d gid=%d chroot=%s", sconf->uid, sconf->gid, sconf->chroot);
+
+    match = -1;
+
+    for(i = 0; i < NUM_CHILDS; i++)
+    {
+        if(CHILD_INFO_TABLE[i].type == CHILD_TYPE_PROCESSOR &&
+           CHILD_INFO_TABLE[i].uid == sconf->uid &&
+           CHILD_INFO_TABLE[i].gid == sconf->gid &&
+           (!sconf->chroot || !strcmp(CHILD_INFO_TABLE[i].chroot, sconf->chroot)) &&
+           (CHILD_INFO_TABLE[i].status == CHILD_STATUS_STANDBY ||
+           CHILD_INFO_TABLE[i].status == CHILD_STATUS_ACTIVE))
+        {
+            _DBG("checking child #%d (%d, %d, %s)", i,
+                CHILD_INFO_TABLE[i].uid,
+                CHILD_INFO_TABLE[i].gid,
+                CHILD_INFO_TABLE[i].chroot);
+
+            if(CHILD_INFO_TABLE[i].status == CHILD_STATUS_STANDBY)
+                return &CHILD_INFO_TABLE[i];
+
+            if(match == -1)
+            {
+                match = i;
+                continue;
+            }
+
+            /* the plan: pick the processor that's been idle the longest.
+               prefer ones in the SERVER_READY state */
+
+            if(ap_scoreboard_image->servers[match][0].status != SERVER_READY && 
+               ap_scoreboard_image->servers[i][0].status == SERVER_READY)
+                match = i;
+
+            if(ap_scoreboard_image->servers[i][0].status ==
+               ap_scoreboard_image->servers[match][0].status &&
+               ap_scoreboard_image->servers[i][0].last_used <
+               ap_scoreboard_image->servers[match][0].last_used)
+                match = i;
+        }
+    }
+
+    if(match == -1) return NULL;
+    return &CHILD_INFO_TABLE[match];
+}
+
+static int pass_request(request_rec *r, child_info_t *processor)
+{
+    int rv;
+    struct msghdr msg;
+    struct cmsghdr *cmsg;
+    int sock_fd;
+    char *bodypart = NULL;
+    struct iovec iov[2];
+    conn_rec *c = r->connection;
+    apr_bucket_brigade *bb = apr_brigade_create(r->pool, c->bucket_alloc);
+    apr_bucket_brigade *bodypart_bb = NULL;
+    apr_size_t len = 0;
+    apr_size_t bodypart_len = 0;
+    peruser_header h;
+    apr_bucket *bucket;
+    const apr_array_header_t *headers_in_array;
+    const apr_table_entry_t *headers_in;
+    int counter;
+
+    apr_socket_t *thesock = ap_get_module_config(r->connection->conn_config, &core_module);
+
+    if ((!r->the_request) || (!strlen(r->the_request)))
+    {
+        _DBG("empty request. dropping it (%ld)", r->the_request);
+        return -1;
+    }
+
+    if (!processor)
+    {
+        _DBG("server %s in child %d has no child_info associated",
+                r->hostname, my_child_num);
+        return -1;
+    }
+
+    _DBG("passing request to another child.  Vhost: %s, child %d %d",
+      apr_table_get(r->headers_in, "Host"), my_child_num, processor->output);
+    _DBG("r->the_request=\"%s\" len=%d", r->the_request, strlen(r->the_request));
+
+    ap_get_brigade(r->connection->input_filters, bb, AP_MODE_EXHAUSTIVE, APR_NONBLOCK_READ, len);
+
+    /* Scan the brigade looking for heap-buckets */
+
+    _DBG("Scanning the brigade",0);
+    bucket = APR_BRIGADE_FIRST(bb);
+    while (bucket != APR_BRIGADE_SENTINEL(bb) &&
+           APR_BUCKET_IS_HEAP(bucket)) {
+       _DBG("HEAP BUCKET is found, length=%d", bucket->length);
+        bucket = APR_BUCKET_NEXT(bucket);
+        if (!APR_BUCKET_IS_HEAP(bucket)) {
+            _DBG("NON-HEAP BUCKET is found, extracting the part of brigade before it",0);
+            bodypart_bb = bb;
+            bb = apr_brigade_split(bodypart_bb, bucket);
+            /* Do we need to apr_destroy_brigade(bb) here?
+             * Yeah, I know we do apr_pool_destroy(r->pool) before return, but
+             * ap_get_brigade is in non-blocking mode (however len is zero).
+             */
+            if (apr_brigade_pflatten(bodypart_bb, &bodypart, &bodypart_len, r->pool) != APR_SUCCESS) {
+                ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                     "Unable to flatten brigade, declining request");
+                apr_pool_destroy(r->pool);
+                return DECLINED;
+            }
+            _DBG("Brigade is flattened as bodypart (bodypart_len=%d)", bodypart_len);
+        }
+    }
+    _DBG("Scanning is finished",0);
+
+    apr_os_sock_get(&sock_fd, thesock);
+
+    h.p = r->pool;
+
+    headers_in_array = apr_table_elts(r->headers_in);
+    headers_in = (const apr_table_entry_t *) headers_in_array->elts;
+
+    h.headers = apr_pstrcat(h.p, r->the_request, CRLF, NULL);
+    for (counter = 0; counter < headers_in_array->nelts; counter++) {
+        if (headers_in[counter].key == NULL
+         || headers_in[counter].val == NULL) {
+             continue;
+         }
+         h.headers = apr_pstrcat(h.p, h.headers, headers_in[counter].key, ": ",
+                                 headers_in[counter].val, CRLF, NULL);
+
+    }
+    h.headers = apr_pstrcat(h.p, h.headers, CRLF, NULL);
+    ap_xlate_proto_to_ascii(h.headers, strlen(h.headers));
+
+    iov[0].iov_base = &bodypart_len;
+    iov[0].iov_len  = sizeof(bodypart_len);
+    iov[1].iov_base = h.headers;
+    iov[1].iov_len  = strlen(h.headers) + 1;
+
+    msg.msg_name    = NULL;
+    msg.msg_namelen = 0;
+    msg.msg_iov     = iov;
+    msg.msg_iovlen  = 2;
+
+    cmsg = apr_palloc(r->pool, sizeof(*cmsg) + sizeof(sock_fd));
+    cmsg->cmsg_len   = sizeof(*cmsg) + sizeof(sock_fd);
+    cmsg->cmsg_level = SOL_SOCKET;
+    cmsg->cmsg_type  = SCM_RIGHTS;
+
+    memcpy(CMSG_DATA(cmsg), &sock_fd, sizeof(sock_fd));
+
+    msg.msg_control    = cmsg;
+    msg.msg_controllen = cmsg->cmsg_len;
+
+
+    if (processor->status == CHILD_STATUS_STANDBY)
+    {
+        _DBG("Activating child #%d", processor->id);
+        processor->status = CHILD_STATUS_STARTING;
+    }
+
+    while (processor->status != CHILD_STATUS_ACTIVE)
+    {
+        _DBG("Waiting for child #%d...", processor->id);
+        sleep(1);
+    }
+
+    _DBG("Writing message to %d, passing sock_fd:  %d", processor->output, sock_fd);
+    _DBG("headers=\"%s\"", h.headers);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                 "Writing message to %d, passing sd:  %d", processor->output, sock_fd);
+
+    if ((rv = sendmsg(processor->output, &msg, 0)) == -1)
+    {
+        apr_pool_destroy(r->pool);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                     "Writing message failed %d %d", rv, errno);
+        return -1;
+    }
+
+    _DBG("Writing message succeeded %d", rv);
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                 "Writing message succeeded %d", rv);
+
+    if (bodypart_len) {
+        _DBG("Passing bodypart (bodypart_len=%d) \"%s\"", bodypart_len, bodypart);
+         if ((rv = send(processor->output, bodypart, bodypart_len, 0)) == -1) {
+             apr_pool_destroy(r->pool);
+             ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                          "Writing message failed %d %d", rv, errno);
+             return -1;
+         }
+        _DBG("Writing message succeeded %d", rv);
+        ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+                     "Writing message succeeded %d", rv);
+    } else {
+        _DBG("No bodypart",0);
+    }
+
+    /* -- close the socket at our site -- */
+    apr_socket_close(thesock);
+    /* DS: What is the purpose of this?
+     *     apr_socket_close(processor->output) seems more reasonable
+     */
+    _DBG("closing socket %d at our side", sock_fd);
+    apr_pool_destroy(r->pool);
+    return 1;
+}
+
+
+static apr_status_t receive_from_multiplexer(
+    void **trans_sock,  /* will be filled out w/ the received socket */
+    ap_listen_rec *lr,  /* listener to receive from */
+    apr_pool_t *ptrans  /* transaction wide pool */
+)
+{
+    struct msghdr msg;
+    struct cmsghdr *cmsg;
+    char headers[HUGE_STRING_LEN];
+    char *bodypart;
+    apr_size_t bodypart_len;
+    struct iovec iov[2];
+    int ret, fd_tmp;
+    apr_os_sock_t ctrl_sock_fd;
+    apr_os_sock_t trans_sock_fd;
+
+    /* -- bucket's, brigades and their allocators */
+    apr_bucket_alloc_t *alloc = apr_bucket_alloc_create(ptrans);
+    apr_bucket_brigade *bb    = apr_brigade_create(ptrans, alloc);
+    apr_bucket         *bucket;
+
+    /* prepare the buffers for receiving data from remote side */
+    iov[0].iov_base = &bodypart_len;
+    iov[0].iov_len  = sizeof(bodypart_len);
+    iov[1].iov_base = headers;
+    iov[1].iov_len  = HUGE_STRING_LEN;
+
+    cmsg = apr_palloc(ptrans, sizeof(*cmsg) + sizeof(trans_sock_fd));
+    cmsg->cmsg_len = sizeof(*cmsg) + sizeof(trans_sock_fd);
+
+    msg.msg_name       = NULL;
+    msg.msg_namelen    = 0;
+    msg.msg_iov        = iov;
+    msg.msg_iovlen     = 2;
+    msg.msg_control    = cmsg;
+    msg.msg_controllen = cmsg->cmsg_len;
+
+    /* -- receive data from socket -- */
+    apr_os_sock_get(&ctrl_sock_fd, lr->sd);
+    _DBG("receiving from sock_fd=%d", ctrl_sock_fd);
+    ret = recvmsg(ctrl_sock_fd, &msg, 0);
+
+    /* -- extract socket from the cmsg -- */
+    memcpy(&trans_sock_fd, CMSG_DATA(cmsg), sizeof(trans_sock_fd));
+    apr_os_sock_put((apr_socket_t **)trans_sock, &trans_sock_fd, ptrans);
+    apr_os_sock_get(&fd_tmp, *trans_sock);
+
+
+    _DBG("trans_sock=%ld fdx=%d sock_fd=%d",
+         *trans_sock, trans_sock_fd, fd_tmp);
+
+    _DBG("headers=\"%s\"", headers);
+
+    /* -- store received data into an brigade and add
+          it to the current transaction's pool -- */
+    bucket = apr_bucket_eos_create(alloc);
+    APR_BRIGADE_INSERT_HEAD(bb, bucket);
+    bucket = apr_bucket_socket_create(*trans_sock, alloc);
+    APR_BRIGADE_INSERT_HEAD(bb, bucket);
+
+    /* Receive the bodypart (if there is one) and insert it in the brigade */
+    if (bodypart_len) {
+        _DBG("Receiving the bodypart (bodypart_len=%d)", bodypart_len);
+        bodypart = apr_palloc(ptrans, bodypart_len);
+        ret = recv(ctrl_sock_fd, bodypart, HUGE_STRING_LEN, 0);
+
+        _DBG("bodypart=\"%s\"", bodypart);
+        bucket = apr_bucket_heap_create(bodypart,
+                                        bodypart_len, NULL, alloc);
+        APR_BRIGADE_INSERT_HEAD(bb, bucket);
+    } else {
+        _DBG("There is no bodypart",0);
+    }
+
+    bucket = apr_bucket_heap_create(headers,
+                                    strlen(headers), NULL, alloc);
+    /* DS: I really don't like that strlen here */
+
+    APR_BRIGADE_INSERT_HEAD(bb, bucket);
+    apr_pool_userdata_set(bb, "PERUSER_SOCKETS", NULL, ptrans);
+
+    _DBG("returning 0", 0);
+    return 0;
+}
+
+
+/* Set group privileges.
+ *
+ * Note that we use the username as set in the config files, rather than
+ * the lookup of to uid --- the same uid may have multiple passwd entries,
+ * with different sets of groups for each.
+ */
+
+static int set_group_privs(uid_t uid, gid_t gid)
+{
+    if (!geteuid())
+    {
+        const char *name;
+
+        /* Get username if passed as a uid */
+
+        struct passwd *ent;
+
+        if ((ent = getpwuid(uid)) == NULL)
+        {
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                         "getpwuid: couldn't determine user name from uid %u, "
+                         "you probably need to modify the User directive",
+                         (unsigned)uid);
+            return -1;
+        }
+
+        name = ent->pw_name;
+
+        /*
+         * Set the GID before initgroups(), since on some platforms
+         * setgid() is known to zap the group list.
+         */
+        if (setgid(gid) == -1)
+        {
+            ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                         "setgid: unable to set group id to Group %u",
+                         (unsigned)gid);
+            return -1;
+        }
+
+        /* Reset `groups' attributes. */
+
+        if (initgroups(name, gid) == -1)
+        {
+                    ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                         "initgroups: unable to set groups for User %s "
+                         "and Group %u", name, (unsigned)gid);
+            return -1;
+        }
+    }
+    return 0;
+}
+
+static int peruser_setup_child(int childnum)
+{
+    child_info_t *ug = &CHILD_INFO_TABLE[childnum];
+
+    if (ug->uid == -1 && ug->gid == -1) {
+        return unixd_setup_child();
+    }
+    if (set_group_privs(ug->uid, ug->gid)) {
+        return -1;
+    }
+    /* Only try to switch if we're running as root */
+    if (!geteuid()
+        && (
+#ifdef _OSD_POSIX
+            os_init_job_environment(ap_server_conf, unixd_config.user_name,
+                                    one_process) != 0 ||
+#endif
+            setuid(ug->uid) == -1)) {
+        ap_log_error(APLOG_MARK, APLOG_ALERT, errno, NULL,
+                     "setuid: unable to change to uid: %ld",
+                     (long) ug->uid);
+        return -1;
+    }
+    return 0;
+}
+
+static int check_signal(int signum)
+{
+    _DBG("signum=%d", signum);
+    switch (signum) {
+    case SIGTERM:
+    case SIGINT:
+        just_die(signum);
+        return 1;
+    }
+    return 0;
+}
+
+/* Send a single HTTP header field to the client.  Note that this function
+ * is used in calls to table_do(), so their interfaces are co-dependent.
+ * In other words, don't change this one without checking table_do in alloc.c.
+ * It returns true unless there was a write error of some kind.
+ */
+static int peruser_header_field(peruser_header *h,
+                             const char *fieldname, const char *fieldval)
+{
+    apr_pstrcat(h->p, h->headers, fieldname, ": ", fieldval, CRLF, NULL);
+    return 1;
+}
+
+static inline ap_listen_rec* listen_add(apr_pool_t* pool, apr_socket_t *sock, void* accept_func)
+{
+    ap_listen_rec *lr_walk, *lr_new;
+
+    _DBG("function entered", 0);
+    /* -- create an new listener for this child -- */
+    lr_new = apr_palloc(pool, sizeof(*lr_new));
+    lr_new->sd          = sock;
+    lr_new->active      = 1;
+    lr_new->accept_func = accept_func;
+    lr_new->next        = NULL;
+
+    /* -- add the new listener_rec into the list -- */
+    /* FIXME: should we somehow lock this list ? */
+    lr_walk = ap_listeners;
+    if (lr_walk)
+    {
+        while (lr_walk->next) lr_walk = lr_walk->next;
+        lr_walk->next = lr_new;
+    }
+    else
+    {
+        ap_listeners = lr_walk = lr_new;
+    }
+    num_listensocks++;
+    return lr_new;
+}
+
+static inline void listen_clear()
+{
+    ap_listen_rec *lr_walk;
+
+    _DBG("function entered", 0);
+
+    /* FIXME: should we somehow lock this list ? */
+    while (ap_listeners)
+    {
+        lr_walk = ap_listeners->next;
+        apr_socket_close(ap_listeners->sd);
+        ap_listeners = lr_walk;
+    }
+    num_listensocks=0;
+}
+
+apr_status_t cleanup_child_info(void *d)
+{
+    if (child_info_image == NULL) {
+        return APR_SUCCESS;
+    }
+
+    free(child_info_image);
+    child_info_image = NULL;
+    apr_shm_destroy(child_info_shm);
+
+    return APR_SUCCESS;
+}
+
+static void child_main(int child_num_arg)
+{
+    apr_pool_t *ptrans;
+    apr_allocator_t *allocator;
+    conn_rec *current_conn;
+    apr_status_t status = APR_EINIT;
+    int i;
+    ap_listen_rec *lr;
+    int curr_pollfd, last_pollfd = 0;
+    apr_pollfd_t *pollset;
+    int offset;
+    ap_sb_handle_t *sbh;
+    apr_status_t rv;
+    apr_bucket_alloc_t *bucket_alloc;
+    int fd;
+    void* sock;
+    void* pod_sock;
+
+    my_child_num = child_num_arg;
+    ap_my_pid = getpid();
+    requests_this_child = 0;
+
+    _DBG("sock_fd_in=%d sock_fd_out=%d",
+         CHILD_INFO_TABLE[my_child_num].input,
+         CHILD_INFO_TABLE[my_child_num].output);
+
+    /* Get a sub context for global allocations in this child, so that
+     * we can have cleanups occur when the child exits.
+     */
+    apr_allocator_create(&allocator);
+    apr_allocator_max_free_set(allocator, ap_max_mem_free);
+    apr_pool_create_ex(&pchild, pconf, NULL, allocator);
+    apr_allocator_owner_set(allocator, pchild);
+
+    apr_pool_create(&ptrans, pchild);
+    apr_pool_tag(ptrans, "transaction");
+
+    /* needs to be done before we switch UIDs so we have permissions */
+    ap_reopen_scoreboard(pchild, NULL, 0);
+
+    rv = apr_proc_mutex_child_init(&accept_mutex, ap_lock_fname, pchild);
+    if (rv != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, ap_server_conf,
+                     "Couldn't initialize cross-process lock in child");
+        clean_child_exit(APEXIT_CHILDFATAL);
+    }
+
+    if(CHILD_INFO_TABLE[my_child_num].chroot) {
+      _DBG("chroot to %s", CHILD_INFO_TABLE[my_child_num].chroot);
+      if(chroot(CHILD_INFO_TABLE[my_child_num].chroot)) {
+        _DBG("chroot failure %s", CHILD_INFO_TABLE[my_child_num].chroot);
+        return;
+      }
+    }
+
+    switch(CHILD_INFO_TABLE[my_child_num].type)
+    {
+        case CHILD_TYPE_MULTIPLEXER:
+            _DBG("MULTIPLEXER %d", my_child_num);
+
+            /* update status on processors that are ready to accept requests */
+            _DBG("updating processor stati", 0);
+            for(i = 0; i < NUM_CHILDS; ++i)
+            {
+                if(CHILD_INFO_TABLE[i].status == CHILD_STATUS_READY)
+                    CHILD_INFO_TABLE[i].status = CHILD_STATUS_ACTIVE;
+            }
+
+            break;
+
+        case CHILD_TYPE_PROCESSOR:
+            _DBG("PROCESSOR %d", my_child_num);
+
+            /* -- create new listener to receive from multiplexer -- */
+            apr_os_sock_put((void*)&sock, &CHILD_INFO_TABLE[my_child_num].input, pconf);
+            listen_clear();
+            listen_add(pconf, sock, receive_from_multiplexer);
+
+            break;
+
+        default:
+            _DBG("unspecified child type for %d sleeping a while ...", my_child_num);
+            sleep(5);
+            return;
+    }
+
+    apr_os_file_get(&fd, pipe_of_death_in);
+    apr_os_sock_put((void*)&pod_sock, &fd, pconf);
+    listen_add(pconf, pod_sock, check_pipe_of_death);
+
+    (peruser_setup_child(my_child_num) && clean_child_exit(APEXIT_CHILDFATAL));
+    ap_run_child_init(pchild, ap_server_conf);
+
+    ap_create_sb_handle(&sbh, pchild, my_child_num, 0);
+    (void) ap_update_child_status(sbh, SERVER_READY, (request_rec *) NULL);
+
+    /* Set up the pollfd array */
+    listensocks = apr_pcalloc(pchild,
+                            sizeof(*listensocks) * (num_listensocks));
+    for (lr = ap_listeners, i = 0; i < num_listensocks; lr = lr->next, i++) {
+        listensocks[i].accept_func = lr->accept_func;
+        listensocks[i].sd = lr->sd;
+    }
+
+    pollset = apr_palloc(pchild, sizeof(*pollset) * num_listensocks);
+    pollset[0].p = pchild;
+    for (i = 0; i < num_listensocks; i++) {
+        pollset[i].desc.s = listensocks[i].sd;
+        pollset[i].desc_type = APR_POLL_SOCKET;
+        pollset[i].reqevents = APR_POLLIN;
+    }
+
+    bucket_alloc = apr_bucket_alloc_create(pchild);
+
+    while (!die_now) {
+	/*
+	 * (Re)initialize this child to a pre-connection state.
+	 */
+
+	current_conn = NULL;
+
+	apr_pool_clear(ptrans);
+
+	if ((ap_max_requests_per_child > 0
+	     && requests_this_child++ >= ap_max_requests_per_child)) {
+            _DBG("max requests reached, dying now", 0);
+	    clean_child_exit(0);
+	}
+
+	(void) ap_update_child_status(sbh, SERVER_READY, (request_rec *) NULL);
+
+	/*
+	 * Wait for an acceptable connection to arrive.
+	 */
+
+	/* Lock around "accept", if necessary */
+	SAFE_ACCEPT(accept_mutex_on());
+
+        if (num_listensocks == 1) {
+            offset = 0;
+        }
+        else {
+            /* multiple listening sockets - need to poll */
+	    for (;;) {
+                apr_status_t ret;
+                apr_int32_t n;
+
+                ret = apr_poll(pollset, num_listensocks, &n, -1);
+                if (ret != APR_SUCCESS) {
+                    if (APR_STATUS_IS_EINTR(ret)) {
+                        continue;
+                    }
+	            /* Single Unix documents select as returning errnos
+	             * EBADF, EINTR, and EINVAL... and in none of those
+	             * cases does it make sense to continue.  In fact
+	             * on Linux 2.0.x we seem to end up with EFAULT
+	             * occasionally, and we'd loop forever due to it.
+	             */
+	            ap_log_error(APLOG_MARK, APLOG_ERR, ret, ap_server_conf,
+                             "apr_poll: (listen)");
+	            clean_child_exit(1);
+                }
+                /* find a listener */
+                curr_pollfd = last_pollfd;
+                do {
+                    curr_pollfd++;
+                    if (curr_pollfd >= num_listensocks) {
+                        curr_pollfd = 0;
+                    }
+                    /* XXX: Should we check for POLLERR? */
+                    if (pollset[curr_pollfd].rtnevents & APR_POLLIN) {
+                        last_pollfd = curr_pollfd;
+                        offset = curr_pollfd;
+                        goto got_fd;
+                    }
+                } while (curr_pollfd != last_pollfd);
+
+                continue;
+            }
+        }
+    got_fd:
+        _DBG("input available ... resetting socket.",0);
+        sock = NULL;    /* important! */
+
+	/* if we accept() something we don't want to die, so we have to
+	 * defer the exit
+	 */
+        status = listensocks[offset].accept_func(&sock, &listensocks[offset], ptrans);
+        SAFE_ACCEPT(accept_mutex_off()); 	/* unlock after "accept" */
+
+        if (status == APR_EGENERAL) {
+            /* resource shortage or should-not-occur occured */
+            clean_child_exit(1);
+        }
+        else if (status != APR_SUCCESS) {
+            continue;
+        }
+
+        if (!setjmp(CHILD_INFO_TABLE[my_child_num].jmpbuffer))
+        {
+            _DBG("marked jmpbuffer",0);
+            _TRACE_CALL("process_socket()",0);
+            process_socket(ptrans, sock, my_child_num, bucket_alloc);
+            _TRACE_RET("process_socket()",0);
+        }
+        else
+        {
+            _DBG("landed from longjmp",0);
+            CHILD_INFO_TABLE[my_child_num].sock_fd = AP_PERUSER_THISCHILD;
+        }
+
+        /* Check the pod and the generation number after processing a
+         * connection so that we'll go away if a graceful restart occurred
+         * while we were processing the connection or we are the lucky
+         * idle server process that gets to die.
+         */
+        if (ap_mpm_pod_check(pod) == APR_SUCCESS) { /* selected as idle? */
+            _DBG("ap_mpm_pod_check(pod) = APR_SUCCESS; dying now", 0);
+            die_now = 1;
+        }
+        else if (ap_my_generation !=
+                 ap_scoreboard_image->global->running_generation) { /* restart? */
+            /* yeah, this could be non-graceful restart, in which case the
+             * parent will kill us soon enough, but why bother checking?
+             */
+            _DBG("ap_my_generation != ap_scoreboard_image->global->running_generation; dying now", 0);
+            die_now = 1;
+        }
+
+        if(CHILD_INFO_TABLE[my_child_num].status == CHILD_STATUS_RESTART)
+        {
+            _DBG("Multiplexer: restarting", 0);
+            die_now = 1;
+        }
+    }
+    clean_child_exit(0);
+}
+
+static const char* child_clone()
+{
+    child_info_t *this;
+    child_info_t *new;
+
+    _DBG("cloning child #%d from #%d", NUM_CHILDS, my_child_num);
+
+    if(NUM_CHILDS >= server_limit)
+    {
+        return "Trying to use more child ID's than NumServers.  "
+               "Increase NumServers in your config file.";
+    }
+
+    this = &CHILD_INFO_TABLE[my_child_num];
+    new = &CHILD_INFO_TABLE[NUM_CHILDS];
+
+    new->uid = this->uid;
+    new->gid = this->gid;
+    new->type = this->type;
+    new->chroot = this->chroot;
+    new->sock_fd = this->sock_fd;
+    new->status = CHILD_STATUS_STARTING;
+    new->input = -1;
+    new->output = -1;
+
+    child_info_image->control->num_childs++;
+    return NULL;
+}
+
+static const char* child_add(int type, int status,
+                             uid_t uid, gid_t gid, const char* chroot)
+{
+    int socks[2];
+
+    _DBG("adding child #%d", NUM_CHILDS);
+
+    if(NUM_CHILDS >= server_limit)
+    {
+        return "Trying to use more child ID's than NumServers.  "
+               "Increase NumServers in your config file.";
+    }
+
+    CHILD_INFO_TABLE[NUM_CHILDS].uid  = uid;
+    CHILD_INFO_TABLE[NUM_CHILDS].gid  = gid;
+    CHILD_INFO_TABLE[NUM_CHILDS].type = type;
+    CHILD_INFO_TABLE[NUM_CHILDS].chroot = chroot;
+    CHILD_INFO_TABLE[NUM_CHILDS].sock_fd = AP_PERUSER_THISCHILD;
+    CHILD_INFO_TABLE[NUM_CHILDS].status = status;
+
+    socketpair(PF_UNIX, SOCK_STREAM, 0, socks);
+    CHILD_INFO_TABLE[NUM_CHILDS].input  = socks[0];
+    CHILD_INFO_TABLE[NUM_CHILDS].output = socks[1];
+
+    _DBG("[%d] uid=%d gid=%d type=%d fd_in=%d fd_out=%d chroot=%s",
+         NUM_CHILDS,
+         CHILD_INFO_TABLE[NUM_CHILDS].uid,
+         CHILD_INFO_TABLE[NUM_CHILDS].gid,
+         CHILD_INFO_TABLE[NUM_CHILDS].type,
+         CHILD_INFO_TABLE[NUM_CHILDS].input,
+         CHILD_INFO_TABLE[NUM_CHILDS].output,
+         CHILD_INFO_TABLE[NUM_CHILDS].chroot);
+
+    if (CHILD_INFO_TABLE[NUM_CHILDS].uid == 0 ||
+        CHILD_INFO_TABLE[NUM_CHILDS].gid == 0)
+    {
+        _DBG("Assigning root user/group to a child.",0);
+    }
+
+    child_info_image->control->num_childs++;
+    return NULL;
+}
+
+static int make_child(server_rec *s, int slot)
+{
+    int pid;
+    int socks[2];
+    child_info_t *multiplexer;
+
+    _DBG("function entered", 0);
+
+    switch (CHILD_INFO_TABLE[slot].type)
+    {
+        case CHILD_TYPE_MULTIPLEXER:            break;
+        case CHILD_TYPE_PROCESSOR:              break;
+        default:
+            _DBG("no valid client in slot %d", slot);
+            sleep(1);
+            return 0;
+    }
+
+    if (slot + 1 > ap_max_daemons_limit) {
+	ap_max_daemons_limit = slot + 1;
+    }
+
+    if (one_process) {
+	apr_signal(SIGHUP, just_die);
+        /* Don't catch AP_SIG_GRACEFUL in ONE_PROCESS mode :) */
+	apr_signal(SIGINT, just_die);
+#ifdef SIGQUIT
+	apr_signal(SIGQUIT, SIG_DFL);
+#endif
+	apr_signal(SIGTERM, just_die);
+	child_main(slot);
+    }
+
+    (void) ap_update_child_status_from_indexes(slot, 0, SERVER_STARTING,
+                                               (request_rec *) NULL);
+
+    if(CHILD_INFO_TABLE[slot].input == -1 &&
+       CHILD_INFO_TABLE[slot].output == -1)
+    {
+        socketpair(PF_UNIX, SOCK_STREAM, 0, socks);
+        CHILD_INFO_TABLE[slot].input  = socks[0];
+        CHILD_INFO_TABLE[slot].output = socks[1];
+
+        if(!(multiplexer = find_next_multiplexer()))
+        {
+            _DBG("no multiplexer found!", 0);
+            sleep(1);
+            return 0;
+        }
+
+        CHILD_INFO_TABLE[slot].status = CHILD_STATUS_READY;
+        multiplexer->status = CHILD_STATUS_RESTART;
+
+        _DBG("New processor added: signaling multiplexer to restart", 0);
+    }
+    else
+    {
+        CHILD_INFO_TABLE[slot].status = CHILD_STATUS_ACTIVE;
+    }
+
+
+#ifdef _OSD_POSIX
+    /* BS2000 requires a "special" version of fork() before a setuid() call */
+    if ((pid = os_fork(unixd_config.user_name)) == -1) {
+#elif defined(TPF)
+    if ((pid = os_fork(s, slot)) == -1) {
+#else
+    if ((pid = fork()) == -1) {
+#endif
+	ap_log_error(APLOG_MARK, APLOG_ERR, errno, s, "fork: Unable to fork new process");
+
+	/* fork didn't succeed. Fix the scoreboard or else
+	 * it will say SERVER_STARTING forever and ever
+	 */
+	(void) ap_update_child_status_from_indexes(slot, 0, SERVER_DEAD,
+                                                   (request_rec *) NULL);
+
+	/* In case system resources are maxxed out, we don't want
+	   Apache running away with the CPU trying to fork over and
+	   over and over again. */
+	sleep(10);
+
+	return -1;
+    }
+
+    if (!pid) {
+#ifdef HAVE_BINDPROCESSOR
+        /* by default AIX binds to a single processor
+         * this bit unbinds children which will then bind to another cpu
+         */
+	int status = bindprocessor(BINDPROCESS, (int)getpid(), 
+				   PROCESSOR_CLASS_ANY);
+	if (status != OK) {
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, 
+                         ap_server_conf, "processor unbind failed %d", status);
+	}
+#endif
+	RAISE_SIGSTOP(MAKE_CHILD);
+        AP_MONCONTROL(1);
+        /* Disable the parent's signal handlers and set up proper handling in
+         * the child.
+	 */
+	apr_signal(SIGHUP, just_die);
+	apr_signal(SIGTERM, just_die);
+        /* The child process doesn't do anything for AP_SIG_GRACEFUL.  
+         * Instead, the pod is used for signalling graceful restart.
+         */
+        /* apr_signal(AP_SIG_GRACEFUL, restart); */
+	child_main(slot);
+        clean_child_exit(0);
+    }
+
+    ap_scoreboard_image->parent[slot].pid = pid;
+    CHILD_INFO_TABLE[slot].pid    = pid;
+
+    ap_child_table[slot].pid    = pid;
+    ap_child_table[slot].status = SERVER_ALIVE;
+
+    return 0;
+}
+
+
+/*
+ * idle_spawn_rate is the number of children that will be spawned on the
+ * next maintenance cycle if there aren't enough idle servers.  It is
+ * doubled up to MAX_SPAWN_RATE, and reset only when a cycle goes by
+ * without the need to spawn.
+ */
+static int idle_spawn_rate = 1;
+#ifndef MAX_SPAWN_RATE
+#define MAX_SPAWN_RATE	(32)
+#endif
+static int hold_off_on_exponential_spawning;
+
+static void perform_idle_server_maintenance(apr_pool_t *p)
+{
+    int i;
+
+    /* _DBG("function entered", 0); */
+
+    for (i = 0; i < NUM_CHILDS; ++i)
+    {
+      if(CHILD_INFO_TABLE[i].pid == 0 &&
+         CHILD_INFO_TABLE[i].status == CHILD_STATUS_STARTING)
+          make_child(ap_server_conf, i);
+    }
+}
+
+
+/*****************************************************************
+ * Executive routines.
+ */
+
+int ap_mpm_run(apr_pool_t *_pconf, apr_pool_t *plog, server_rec *s)
+{
+    int i;
+/*    int fd; */
+    apr_status_t rv;
+    apr_size_t one = 1;
+/*    apr_socket_t *sock = NULL; */
+
+    ap_log_pid(pconf, ap_pid_fname);
+
+    first_server_limit = server_limit;
+    if (changed_limit_at_restart) {
+        ap_log_error(APLOG_MARK, APLOG_WARNING, 0, s,
+                     "WARNING: Attempt to change ServerLimit "
+                     "ignored during restart");
+        changed_limit_at_restart = 0;
+    }
+
+    ap_server_conf = s;
+
+    /* Initialize cross-process accept lock */
+    ap_lock_fname = apr_psprintf(_pconf, "%s.%" APR_PID_T_FMT,
+                                 ap_server_root_relative(_pconf, ap_lock_fname),
+                                 ap_my_pid);
+
+    rv = apr_proc_mutex_create(&accept_mutex, ap_lock_fname, 
+                               ap_accept_lock_mech, _pconf);
+    if (rv != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
+                     "Couldn't create accept lock");
+        return 1;
+    }
+
+#if 0
+#if APR_USE_SYSVSEM_SERIALIZE
+    if (ap_accept_lock_mech == APR_LOCK_DEFAULT || 
+        ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
+#else
+    if (ap_accept_lock_mech == APR_LOCK_SYSVSEM) {
+#endif
+        rv = unixd_set_proc_mutex_perms(accept_mutex);
+        if (rv != APR_SUCCESS) {
+            ap_log_error(APLOG_MARK, APLOG_EMERG, rv, s,
+                         "Couldn't set permissions on cross-process lock; "
+                         "check User and Group directives");
+            return 1;
+        }
+    }
+#endif
+
+    if (!is_graceful) {
+        if (ap_run_pre_mpm(s->process->pool, SB_SHARED) != OK) {
+            return 1;
+        }
+        /* fix the generation number in the global score; we just got a new,
+         * cleared scoreboard
+         */
+        ap_scoreboard_image->global->running_generation = ap_my_generation;
+    }
+
+    /* Initialize the child table */
+    if (!is_graceful)
+    {
+        for (i = 0; i < server_limit; i++)
+       {
+            ap_child_table[i].pid = 0;
+        }
+    }
+
+    /* We need to put the new listeners at the end of the ap_listeners
+     * list.  If we don't, then the pool will be cleared before the
+     * open_logs phase is called for the second time, and ap_listeners
+     * will have only invalid data.  If that happens, then the sockets
+     * that we opened using make_sock() will be lost, and the server
+     * won't start.
+     */
+
+/*
+    apr_os_file_get(&fd, pipe_of_death_in);
+    apr_os_sock_put(&sock, &fd, pconf);
+
+    listen_add(pconf, sock, check_pipe_of_death);
+*/
+    set_signals();
+
+    if (one_process) {
+        AP_MONCONTROL(1);
+    }
+
+    ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+		"%s configured -- resuming normal operations",
+		ap_get_server_version());
+    ap_log_error(APLOG_MARK, APLOG_INFO, 0, ap_server_conf,
+		"Server built: %s", ap_get_server_built());
+#ifdef AP_MPM_WANT_SET_ACCEPT_LOCK_MECH
+    ap_log_error(APLOG_MARK, APLOG_DEBUG, 0, ap_server_conf,
+		"AcceptMutex: %s (default: %s)",
+		apr_proc_mutex_name(accept_mutex),
+		apr_proc_mutex_defname());
+#endif
+    restart_pending = shutdown_pending = 0;
+
+    _DBG("sizeof(child_info_t) = %d", sizeof(child_info_t));
+
+    while (!restart_pending && !shutdown_pending) {
+	int child_slot;
+        apr_exit_why_e exitwhy;
+	int status, processed_status;
+        /* this is a memory leak, but I'll fix it later. */
+	apr_proc_t pid;
+
+        ap_wait_or_timeout(&exitwhy, &status, &pid, pconf);
+
+	/* XXX: if it takes longer than 1 second for all our children
+	 * to start up and get into IDLE state then we may spawn an
+	 * extra child
+	 */
+	if (pid.pid != -1) {
+            processed_status = ap_process_child_status(&pid, exitwhy, status);
+            if (processed_status == APEXIT_CHILDFATAL) {
+                return 1;
+            }
+
+            /* non-fatal death... note that it's gone in the scoreboard. */
+            child_slot = find_child_by_pid(&pid);
+            _DBG("child #%d has died ...", child_slot);
+
+            for (i = 0; i < ap_max_daemons_limit; ++i)
+            {
+                if (ap_child_table[i].pid == pid.pid)
+                {
+                    child_slot = i;
+                    break;
+                }
+            }
+
+	    if (child_slot >= 0) {
+                ap_child_table[child_slot].pid = 0;
+                _TRACE_CALL("ap_update_child_status_from_indexes", 0);
+		(void) ap_update_child_status_from_indexes(child_slot, 0, SERVER_DEAD,
+                                                           (request_rec *) NULL);
+                _TRACE_RET("ap_update_child_status_from_indexes", 0);
+
+                if (processed_status == APEXIT_CHILDSICK) {
+                    /* child detected a resource shortage (E[NM]FILE, ENOBUFS, etc)
+                     * cut the fork rate to the minimum 
+                     */
+                    _DBG("processed_status = APEXIT_CHILDSICK", 0);
+                    idle_spawn_rate = 1; 
+                }
+                else if(child_slot < ap_daemons_limit) {
+		    /* we're still doing a 1-for-1 replacement of dead
+			* children with new children
+			*/
+                    _DBG("replacing by new child ...", 0);
+		    make_child(ap_server_conf, child_slot);
+		}
+#if APR_HAS_OTHER_CHILD
+	    }
+	    else if (apr_proc_other_child_read(&pid, status) == 0) {
+                _DBG("APR_HAS_OTHER_CHILD, apparently", 0);
+		/* handled */
+#endif
+	    }
+	    else if (is_graceful) {
+		/* Great, we've probably just lost a slot in the
+		    * scoreboard.  Somehow we don't know about this
+		    * child.
+		    */
+                _DBG("long lost child came home, whatever that means", 0);
+
+		ap_log_error(APLOG_MARK, APLOG_WARNING, 
+                            0, ap_server_conf,
+			    "long lost child came home! (pid %ld)", (long)pid.pid);
+	    }
+	    /* Don't perform idle maintenance when a child dies,
+		* only do it when there's a timeout.  Remember only a
+		* finite number of children can die, and it's pretty
+		* pathological for a lot to die suddenly.
+		*/
+	    continue;
+	}
+
+	perform_idle_server_maintenance(pconf);
+#ifdef TPF
+        shutdown_pending = os_check_server(tpf_server_name);
+        ap_check_signals();
+        sleep(1);
+#endif /*TPF */
+    }
+
+    if (shutdown_pending) {
+	/* Time to gracefully shut down:
+	 * Kill child processes, tell them to call child_exit, etc...
+	 */
+	if (unixd_killpg(getpgrp(), SIGTERM) < 0) {
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGTERM");
+	}
+	ap_reclaim_child_processes(1);		/* Start with SIGTERM */
+
+	/* cleanup pid file on normal shutdown */
+	{
+	    const char *pidfile = NULL;
+	    pidfile = ap_server_root_relative (pconf, ap_pid_fname);
+	    if ( pidfile != NULL && unlink(pidfile) == 0)
+		ap_log_error(APLOG_MARK, APLOG_INFO,
+				0, ap_server_conf,
+				"removed PID file %s (pid=%ld)",
+				pidfile, (long)getpid());
+	}
+
+	ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+		    "caught SIGTERM, shutting down");
+	return 1;
+    }
+
+    /* we've been told to restart */
+    apr_signal(SIGHUP, SIG_IGN);
+    if (one_process) {
+	/* not worth thinking about */
+	return 1;
+    }
+
+    /* advance to the next generation */
+    /* XXX: we really need to make sure this new generation number isn't in
+     * use by any of the children.
+     */
+    ++ap_my_generation;
+    ap_scoreboard_image->global->running_generation = ap_my_generation;
+    
+    if (is_graceful) {
+        char char_of_death = AP_PERUSER_CHAR_OF_DEATH;
+
+	ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+		    "Graceful restart requested, doing restart");
+
+#if 0
+	/* kill off the idle ones */
+        ap_mpm_pod_killpg(pod, ap_max_daemons_limit);
+
+	/* This is mostly for debugging... so that we know what is still
+	    * gracefully dealing with existing request.  This will break
+	    * in a very nasty way if we ever have the scoreboard totally
+	    * file-based (no shared memory)
+	    */
+	for (i = 0; i < ap_daemons_limit; ++i) {
+	    if (ap_scoreboard_image->servers[i][0].status != SERVER_DEAD) {
+		ap_scoreboard_image->servers[i][0].status = SERVER_GRACEFUL;
+	    }
+	}
+#endif
+
+        ap_log_error(APLOG_MARK, APLOG_NOTICE, 0,
+                     ap_server_conf, AP_SIG_GRACEFUL_STRING " received.  "
+                     "Doing graceful restart");
+
+        /* This is mostly for debugging... so that we know what is still
+         * gracefully dealing with existing request.
+         */
+
+        for (i = 0; i < NUM_CHILDS; ++i)
+        {
+            ((ap_child_table[i].pid) && (ap_child_table[i].status = SERVER_DYING));
+        }
+
+        /* give the children the signal to die */
+        for (i = 0; i < NUM_CHILDS;)
+        {
+            if ((rv = apr_file_write(pipe_of_death_out, &char_of_death, &one)) != APR_SUCCESS)
+            {
+                if (APR_STATUS_IS_EINTR(rv)) continue;
+                ap_log_error(APLOG_MARK, APLOG_WARNING, rv, ap_server_conf,
+                             "write pipe_of_death");
+            }
+            i++;
+        }
+    }
+    else {
+	/* Kill 'em off */
+	if (unixd_killpg(getpgrp(), SIGHUP) < 0) {
+	    ap_log_error(APLOG_MARK, APLOG_WARNING, errno, ap_server_conf, "killpg SIGHUP");
+	}
+	ap_reclaim_child_processes(0);		/* Not when just starting up */
+	ap_log_error(APLOG_MARK, APLOG_NOTICE, 0, ap_server_conf,
+		    "SIGHUP received.  Attempting to restart");
+    }
+
+    return 0;
+}
+
+/* == allocate an private server config structure == */
+static void *peruser_create_config(apr_pool_t *p, server_rec *s)
+{
+    peruser_server_conf *c = (peruser_server_conf *)
+                                  apr_pcalloc(p, sizeof(peruser_server_conf));
+    c->max_processors = 5;
+    c->last_child = 0;
+    return c;
+}
+
+/* This really should be a post_config hook, but the error log is already
+ * redirected by that point, so we need to do this in the open_logs phase.
+ */
+static int peruser_open_logs(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *s)
+{
+    apr_status_t rv;
+
+    pconf = p;
+    ap_server_conf = s;
+
+    if ((num_listensocks = ap_setup_listeners(ap_server_conf)) < 1) {
+        ap_log_error(APLOG_MARK, APLOG_ALERT|APLOG_STARTUP, 0, 
+                     NULL, "no listening sockets available, shutting down");
+	return DONE;
+    }
+
+    ap_log_pid(pconf, ap_pid_fname);
+
+    if ((rv = ap_mpm_pod_open(pconf, &pod))) {
+        ap_log_error(APLOG_MARK, APLOG_CRIT|APLOG_STARTUP, rv, NULL,
+		"Could not open pipe-of-death.");
+        return DONE;
+    }
+
+    if ((rv = apr_file_pipe_create(&pipe_of_death_in, &pipe_of_death_out,
+                                   pconf)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv,
+                     (const server_rec*) ap_server_conf,
+                     "apr_file_pipe_create (pipe_of_death)");
+        exit(1);
+    }
+    if ((rv = apr_file_pipe_timeout_set(pipe_of_death_in, 0)) != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_ERR, rv,
+                     (const server_rec*) ap_server_conf,
+                     "apr_file_pipe_timeout_set (pipe_of_death)");
+        exit(1);
+    }
+
+    return OK;
+}
+
+static int peruser_pre_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp)
+{
+    static int restart_num = 0;
+    int no_detach, debug, foreground, i;
+    int tmp_server_limit = DEFAULT_SERVER_LIMIT;
+    ap_directive_t *pdir;
+    apr_status_t rv;
+    apr_pool_t *global_pool;
+    void *shmem;
+
+    debug = ap_exists_config_define("DEBUG");
+
+    if (debug) {
+        foreground = one_process = 1;
+        no_detach = 0;
+    }
+    else
+    {
+        no_detach = ap_exists_config_define("NO_DETACH");
+        one_process = ap_exists_config_define("ONE_PROCESS");
+        foreground = ap_exists_config_define("FOREGROUND");
+    }
+
+    /* sigh, want this only the second time around */
+    if (restart_num++ == 1) {
+	is_graceful = 0;
+
+        if (!one_process && !foreground) {
+            rv = apr_proc_detach(no_detach ? APR_PROC_DETACH_FOREGROUND
+                                           : APR_PROC_DETACH_DAEMONIZE);
+            if (rv != APR_SUCCESS) {
+                ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                             "apr_proc_detach failed");
+                return HTTP_INTERNAL_SERVER_ERROR;
+            }
+        }
+
+	parent_pid = ap_my_pid = getpid();
+    }
+
+    unixd_pre_config(ptemp);
+    ap_listen_pre_config();
+    ap_daemons_min_free = DEFAULT_MIN_FREE_DAEMON;
+    ap_max_processors = DEFAULT_MAX_PROCESSORS;
+    ap_daemons_limit = server_limit;
+    ap_pid_fname = DEFAULT_PIDLOG;
+    ap_lock_fname = DEFAULT_LOCKFILE;
+    ap_max_requests_per_child = DEFAULT_MAX_REQUESTS_PER_CHILD;
+    ap_extended_status = 0;
+#ifdef AP_MPM_WANT_SET_MAX_MEM_FREE
+	ap_max_mem_free = APR_ALLOCATOR_MAX_FREE_UNLIMITED;
+#endif
+
+    apr_cpystrn(ap_coredump_dir, ap_server_root, sizeof(ap_coredump_dir));
+
+    /* we need to know ServerLimit and ThreadLimit before we start processing
+     * the tree because we need to already have allocated child_info_table
+     */
+    for (pdir = ap_conftree; pdir != NULL; pdir = pdir->next)
+    {
+        if (!strcasecmp(pdir->directive, "ServerLimit"))
+        {
+            if (atoi(pdir->args) > tmp_server_limit)
+            {
+                tmp_server_limit = atoi(pdir->args);
+                if (tmp_server_limit > MAX_SERVER_LIMIT)
+                {
+                    tmp_server_limit = MAX_SERVER_LIMIT;
+                }
+            }
+        }
+    }
+
+    _DBG("Initializing child_info_table", 0);
+    child_info_size = tmp_server_limit * sizeof(child_info_t) + sizeof(apr_size_t);
+
+    /* We don't want to have to recreate the scoreboard after
+     * restarts, so we'll create a global pool and never clean it.
+     */
+    rv = apr_pool_create(&global_pool, NULL);
+    if (rv != APR_SUCCESS) {
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                     "Fatal error: unable to create global pool");
+        return rv;
+    }
+
+    rv = apr_shm_create(&child_info_shm, child_info_size, NULL, global_pool);
+
+/*  if ((rv != APR_SUCCESS) && (rv != APR_ENOTIMPL)) { */
+    if (rv != APR_SUCCESS) {
+        _DBG("shared memory creation failed", 0);
+
+        ap_log_error(APLOG_MARK, APLOG_CRIT, rv, NULL,
+                     "Unable to create shared memory segment "
+                     "(anonymous shared memory failure)");
+    }
+    else if (rv == APR_ENOTIMPL) {
+        _DBG("anonymous shared memory not available", 0);
+        /* TODO: make up a filename and do name-based shmem */
+    }
+
+    if (rv || !(shmem = apr_shm_baseaddr_get(child_info_shm))) {
+        _DBG("apr_shm_baseaddr_get() failed", 0);
+        return HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    memset(shmem, 0, sizeof(child_info_size));
+    child_info_image = (child_info*)calloc(1, sizeof(child_info_size));
+    child_info_image->control = (child_info_control*)shmem;
+    shmem += sizeof(child_info_control*);
+    child_info_image->table = (child_info_t*)shmem;
+
+    child_info_image->control->num_childs = 0;
+
+    for (i = 0; i < tmp_server_limit; i++)
+    {
+        CHILD_INFO_TABLE[i].uid     = -1;
+        CHILD_INFO_TABLE[i].gid     = -1;
+        CHILD_INFO_TABLE[i].chroot  = NULL;
+        CHILD_INFO_TABLE[i].input   = -1;
+        CHILD_INFO_TABLE[i].output  = -1;
+        CHILD_INFO_TABLE[i].type    = -1;
+        CHILD_INFO_TABLE[i].status  = CHILD_STATUS_STANDBY;
+        CHILD_INFO_TABLE[i].sock_fd = -3; /* -1 and -2 are taken */
+        CHILD_INFO_TABLE[i].id      = i;
+    }
+
+    return OK;
+}
+
+static int peruser_post_config(apr_pool_t *p, apr_pool_t *plog, apr_pool_t *ptemp, server_rec *server_list)
+{
+    ap_child_table = (ap_ctable *)apr_pcalloc(p, server_limit * sizeof(ap_ctable));
+
+    return OK;
+}
+
+static int peruser_post_read(request_rec *r)
+{
+    peruser_server_conf *sconf = PERUSER_SERVER_CONF(r->server->module_config);
+    child_info_t *processor;
+
+    if(CHILD_INFO_TABLE[my_child_num].type == CHILD_TYPE_MULTIPLEXER)
+        processor = find_next_processor(sconf);
+    else if(CHILD_INFO_TABLE[my_child_num].type == CHILD_TYPE_PROCESSOR)
+        processor = &CHILD_INFO_TABLE[r->connection->id];
+
+    if(!processor)
+    {
+      _DBG("processor not found");
+      processor = &CHILD_INFO_TABLE[r->connection->id];
+    }
+
+    if (!strlen(r->the_request))
+    {
+        _DBG("corrupt request. aborting",0);
+        return DECLINED;
+    }
+
+    if (processor->sock_fd != AP_PERUSER_THISCHILD)
+    {
+        apr_socket_t *sock = NULL;
+
+        apr_os_sock_put(&sock, &processor->sock_fd, r->connection->pool);
+        ap_sock_disable_nagle(sock);
+        ap_set_module_config(r->connection->conn_config, &core_module, sock);
+        _DBG("not the right socket?", 0);
+        return OK;
+    }
+
+    switch (CHILD_INFO_TABLE[my_child_num].type)
+    {
+        case CHILD_TYPE_MULTIPLEXER:
+        {
+            _DBG("MULTIPLEXER => Determining if request should be passed. "
+                 "Child Num: %d, dest-child: %d, hostname from server: %s r->hostname=%s r->the_request=\"%s\"",
+                my_child_num, processor->id, r->server->server_hostname, r->hostname, r->the_request);
+
+            if (processor->id != my_child_num)
+            {
+                if (processor->status == CHILD_STATUS_STANDBY)
+                {
+                    _DBG("Activating child #%d", processor->id);
+                    processor->status = CHILD_STATUS_STARTING;
+                }
+
+                _DBG("Passing request.",0);
+                if (pass_request(r, processor) == -1)
+                {
+                    ap_log_error(APLOG_MARK, APLOG_ERR, 0,
+                             ap_server_conf, "Could not pass request to proper "                             "child, request will not be honoured.");
+                    return DECLINED;
+                }
+                _DBG("doing longjmp",0);
+                longjmp(CHILD_INFO_TABLE[my_child_num].jmpbuffer, 1);
+                _DBG("request declined at our site",0);
+                return DECLINED;
+                _DBG("OUH! we should never reach this point",0);
+            }
+            _DBG("WTF: the server is assigned to the multiplexer! ... dropping request",0);
+            return DECLINED;
+        }
+        case CHILD_TYPE_PROCESSOR:
+        {
+            _DBG("PROCESSOR %d", my_child_num);
+            if (processor->id != my_child_num)
+            {
+                _DBG("WTF: this server is not assigned to us! what has the mux been smoking?!",0);
+            }
+            _DBG("request for %s / (server %s) seems to be for us", r->hostname, r->server->server_hostname);
+
+            /* TODO: add configuration for max processors per server */
+            if (total_processors(sconf) > ap_max_processors) return DECLINED;
+            if (idle_processors(sconf) < ap_daemons_min_free) child_clone();
+
+            return OK;
+        }
+        default:
+        {
+            _DBG("unspecified child type %d in %d, dropping request",
+                 CHILD_INFO_TABLE[my_child_num].type, my_child_num);
+            return OK;
+        }
+    }
+
+    _DBG("THIS POINT SHOULD NOT BE REACHED!",0);
+    return OK;
+}
+
+static void peruser_hooks(apr_pool_t *p)
+{
+    /* The peruser open_logs phase must run before the core's, or stderr
+     * will be redirected to a file, and the messages won't print to the
+     * console.
+     */
+    static const char *const aszSucc[] = {"core.c", NULL};
+
+#ifdef AUX3
+    (void) set42sig();
+#endif
+
+    ap_hook_open_logs(peruser_open_logs, NULL, aszSucc, APR_HOOK_MIDDLE);
+    ap_hook_pre_config(peruser_pre_config, NULL, NULL, APR_HOOK_MIDDLE);
+    ap_hook_post_config(peruser_post_config, NULL, NULL, APR_HOOK_MIDDLE);
+
+    /* Both of these must be run absolutely first.  If this request isn't for
+     * this server then we need to forward it to the proper child.  No sense
+     * tying up this server running more post_read request hooks if it is
+     * just going to be forwarded along.  The process_connection hook allows
+     * peruser to receive the passed request correctly, by automatically
+     * filling in the core_input_filter's ctx pointer.
+     */
+    ap_hook_post_read_request(peruser_post_read, NULL, NULL,
+                              APR_HOOK_REALLY_FIRST);
+    ap_hook_process_connection(peruser_process_connection, NULL, NULL,
+                               APR_HOOK_REALLY_FIRST);
+}
+
+/* we define an Processor w/ specific uid/gid */
+static const char *cf_Processor(cmd_parms *cmd, void *dummy,
+    const char *user_name, const char *group_name, const char *chroot)
+{
+    uid_t uid = ap_uname2id(user_name);
+    gid_t gid = ap_gname2id(group_name);
+
+    _DBG("user=%s:%d group=%s:%d chroot=%s",
+        user_name, uid, group_name, gid, chroot);
+
+    return child_add(CHILD_TYPE_PROCESSOR, CHILD_STATUS_STANDBY,
+                     uid, gid, chroot);
+}
+
+/* we define an Multiplexer child w/ specific uid/gid */
+static const char *cf_Multiplexer(cmd_parms *cmd, void *dummy,
+    const char *user_name, const char *group_name, const char *chroot)
+{
+    uid_t uid = ap_uname2id(user_name);
+    gid_t gid = ap_gname2id(group_name);
+
+    _DBG("user=%s:%d group=%s:%d chroot=%s [multiplexer id %d]",
+        user_name, uid, group_name, gid, chroot, NUM_CHILDS);
+
+    return child_add(CHILD_TYPE_MULTIPLEXER, CHILD_STATUS_STARTING,
+                     uid, gid, chroot);
+}
+
+static const char* cf_ServerEnvironment(cmd_parms *cmd, void *dummy,
+    const char *user_name, const char *group_name, const char *chroot)
+{
+    int uid = ap_uname2id(user_name);
+    int gid = ap_gname2id(group_name);
+    peruser_server_conf *sconf;
+
+    _DBG("function entered", 0);
+
+    sconf = PERUSER_SERVER_CONF(cmd->server->module_config);
+
+    sconf->fullsockname = apr_pstrcat(cmd->pool, sconf->sockname, ".",
+        user_name,":", group_name, NULL);
+
+    sconf->uid = uid;
+    sconf->gid = gid;
+    sconf->chroot = chroot;
+
+    _DBG("user=%s:%d group=%s:%d chroot=%s numchilds=%d",
+        user_name, uid, group_name, gid, chroot, NUM_CHILDS);
+
+    return NULL;
+}
+
+/*
+static const char *cf_MaxProcessorsPerServer(cmd_parms *cmd, void *dummy, const char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) return err;
+
+    max_processors = atoi(arg);
+    return NULL;
+}
+*/
+
+static const char *set_min_free_servers(cmd_parms *cmd, void *dummy, const char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_daemons_min_free = atoi(arg);
+    if (ap_daemons_min_free <= 0) {
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "WARNING: detected MinSpareServers set to non-positive.");
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "Resetting to 1 to avoid almost certain Apache failure.");
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "Please read the documentation.");
+       ap_daemons_min_free = 1;
+    }
+       
+    return NULL;
+}
+
+static const char *set_max_clients (cmd_parms *cmd, void *dummy, const char *arg) 
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_daemons_limit = atoi(arg);
+    if (ap_daemons_limit > server_limit) {
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "WARNING: MaxClients of %d exceeds ServerLimit value "
+                    "of %d servers,", ap_daemons_limit, server_limit);
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    " lowering MaxClients to %d.  To increase, please "
+                    "see the ServerLimit", server_limit);
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+                    " directive.");
+       ap_daemons_limit = server_limit;
+    } 
+    else if (ap_daemons_limit < 1) {
+	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                     "WARNING: Require MaxClients > 0, setting to 1");
+	ap_daemons_limit = 1;
+    }
+    return NULL;
+}
+
+static const char *set_max_processors (cmd_parms *cmd, void *dummy, const char *arg)
+{
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    ap_max_processors = atoi(arg);
+
+    if (ap_max_processors < 1) {
+        ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL,
+                     "WARNING: Require MaxProcessors > 0, setting to 1");
+        ap_max_processors = 1;
+    }
+    return NULL;
+}
+
+static const char *set_server_limit (cmd_parms *cmd, void *dummy, const char *arg) 
+{
+    int tmp_server_limit;
+    
+    const char *err = ap_check_cmd_context(cmd, GLOBAL_ONLY);
+    if (err != NULL) {
+        return err;
+    }
+
+    tmp_server_limit = atoi(arg);
+    /* you cannot change ServerLimit across a restart; ignore
+     * any such attempts
+     */
+    if (first_server_limit &&
+        tmp_server_limit != server_limit) {
+        /* how do we log a message?  the error log is a bit bucket at this
+         * point; we'll just have to set a flag so that ap_mpm_run()
+         * logs a warning later
+         */
+        changed_limit_at_restart = 1;
+        return NULL;
+    }
+    server_limit = tmp_server_limit;
+    
+    if (server_limit > MAX_SERVER_LIMIT) {
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    "WARNING: ServerLimit of %d exceeds compile time limit "
+                    "of %d servers,", server_limit, MAX_SERVER_LIMIT);
+       ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                    " lowering ServerLimit to %d.", MAX_SERVER_LIMIT);
+       server_limit = MAX_SERVER_LIMIT;
+    } 
+    else if (server_limit < 1) {
+	ap_log_error(APLOG_MARK, APLOG_STARTUP, 0, NULL, 
+                     "WARNING: Require ServerLimit > 0, setting to 1");
+	server_limit = 1;
+    }
+    return NULL;
+}
+
+static const command_rec peruser_cmds[] = {
+UNIX_DAEMON_COMMANDS,
+LISTEN_COMMANDS,
+AP_INIT_TAKE1("MinSpareServers", set_min_free_servers, NULL, RSRC_CONF,
+              "Minimum number of idle children, to handle request spikes"),
+AP_INIT_TAKE1("MaxClients", set_max_clients, NULL, RSRC_CONF,
+              "Maximum number of children alive at the same time"),
+AP_INIT_TAKE1("MaxProcessors", set_max_processors, NULL, RSRC_CONF,
+              "Maximum number of processors per vhost"),
+AP_INIT_TAKE1("ServerLimit", set_server_limit, NULL, RSRC_CONF,
+              "Maximum value of MaxClients for this run of Apache"),
+AP_INIT_TAKE23("Multiplexer", cf_Multiplexer, NULL, RSRC_CONF,
+              "Specify an Multiplexer Child configuration."),
+AP_INIT_TAKE23("Processor", cf_Processor, NULL, RSRC_CONF,
+              "Specify a User and Group for a specific child process."),
+AP_INIT_TAKE23("ServerEnvironment", cf_ServerEnvironment, NULL, RSRC_CONF,
+              "Specify the server environment for this virtual host."),
+{ NULL }
+};
+
+module AP_MODULE_DECLARE_DATA mpm_peruser_module = {
+    MPM20_MODULE_STUFF,
+    ap_mpm_rewrite_args,        /* hook to run before apache parses args */
+    NULL,			/* create per-directory config structure */
+    NULL,			/* merge per-directory config structures */
+    peruser_create_config,	/* create per-server config structure */
+    NULL,			/* merge per-server config structures */
+    peruser_cmds,		/* command apr_table_t */
+    peruser_hooks,		/* register hooks */
+};
diff -Nur httpd-2.0.52/srclib/apr/network_io/unix/sockets.c httpd-2.0.52-metux-peruser/srclib/apr/network_io/unix/sockets.c
--- httpd-2.0.52/srclib/apr/network_io/unix/sockets.c	2004-04-15 22:17:58.000000000 +0200
+++ httpd-2.0.52-metux-peruser/srclib/apr/network_io/unix/sockets.c	2004-10-18 15:58:44.172074656 +0200
@@ -379,7 +379,36 @@
         set_socket_vars(*sock, APR_INET, SOCK_STREAM, 0);
         (*sock)->timeout = -1;
     }
-    (*sock)->local_port_unknown = (*sock)->local_interface_unknown = 1;
+//    (*sock)->local_port_unknown = (*sock)->local_interface_unknown = 1;
+     if (1)
+     {
+       /* fixup socket's peer information.
+          we need it for the muxmpm.           enrico weigelt, metux ITS
+                                               <weigelt@metux.de>
+       */
+       /* XXX next line looks bogus w.r.t. AF_INET6 support */
+
+       /* adjust remote address */
+       (*sock)->remote_addr->salen = sizeof((*sock)->remote_addr->sa);
+         getpeername(
+           *thesock,
+           (struct sockaddr*)&((*sock)->remote_addr->sa),
+           &((*sock)->remote_addr->salen)
+       );
+         (*sock)->remote_addr->port = ntohs((*sock)->remote_addr->sa.sin.sin_port);
+
+         /* XXX assumes sin_port and sin6_port at same offset */
+
+       /* adjust local address */
+         getsockname(
+           *thesock,
+           (struct sockaddr*)&((*sock)->local_addr->sa),
+           &((*sock)->local_addr->salen)
+       );
+         (*sock)->local_addr->port = ntohs((*sock)->local_addr->sa.sin.sin_port);
+       (*sock)->local_port_unknown = (*sock)->local_interface_unknown = 0;
+     }
+
     (*sock)->remote_addr_unknown = 1;
     (*sock)->socketdes = *thesock;
     return APR_SUCCESS;
diff -Nur httpd-2.0.52/srclib/apr/network_io/unix/sockets.c.orig httpd-2.0.52-metux-peruser/srclib/apr/network_io/unix/sockets.c.orig
--- httpd-2.0.52/srclib/apr/network_io/unix/sockets.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ httpd-2.0.52-metux-peruser/srclib/apr/network_io/unix/sockets.c.orig	2004-04-15 22:17:58.000000000 +0200
@@ -0,0 +1,421 @@
+/* Copyright 2000-2004 The Apache Software Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "apr_arch_networkio.h"
+#include "apr_network_io.h"
+#include "apr_strings.h"
+#include "apr_support.h"
+#include "apr_portable.h"
+#include "apr_arch_inherit.h"
+
+#if defined(BEOS) && !defined(BEOS_BONE)
+#define close closesocket
+#endif
+
+static char generic_inaddr_any[16] = {0}; /* big enough for IPv4 or IPv6 */
+
+static apr_status_t socket_cleanup(void *sock)
+{
+    apr_socket_t *thesocket = sock;
+
+    if (close(thesocket->socketdes) == 0) {
+        thesocket->socketdes = -1;
+        return APR_SUCCESS;
+    }
+    else {
+        return errno;
+    }
+}
+
+static void set_socket_vars(apr_socket_t *sock, int family, int type, int protocol)
+{
+    sock->type = type;
+    sock->protocol = protocol;
+    apr_sockaddr_vars_set(sock->local_addr, family, 0);
+    apr_sockaddr_vars_set(sock->remote_addr, family, 0);
+    sock->netmask = 0;
+#if defined(BEOS) && !defined(BEOS_BONE)
+    /* BeOS pre-BONE has TCP_NODELAY on by default and it can't be
+     * switched off!
+     */
+    sock->netmask |= APR_TCP_NODELAY;
+#endif
+}
+
+static void alloc_socket(apr_socket_t **new, apr_pool_t *p)
+{
+    *new = (apr_socket_t *)apr_pcalloc(p, sizeof(apr_socket_t));
+    (*new)->cntxt = p;
+    (*new)->local_addr = (apr_sockaddr_t *)apr_pcalloc((*new)->cntxt,
+                                                       sizeof(apr_sockaddr_t));
+    (*new)->local_addr->pool = p;
+    (*new)->remote_addr = (apr_sockaddr_t *)apr_pcalloc((*new)->cntxt,
+                                                        sizeof(apr_sockaddr_t));
+    (*new)->remote_addr->pool = p;
+}
+
+apr_status_t apr_socket_protocol_get(apr_socket_t *sock, int *protocol)
+{
+    *protocol = sock->protocol;
+    return APR_SUCCESS;
+}
+
+apr_status_t apr_socket_create_ex(apr_socket_t **new, int ofamily, int type,
+                                  int protocol, apr_pool_t *cont)
+{
+    int family = ofamily;
+
+    if (family == APR_UNSPEC) {
+#if APR_HAVE_IPV6
+        family = APR_INET6;
+#else
+        family = APR_INET;
+#endif
+    }
+
+    alloc_socket(new, cont);
+
+    (*new)->socketdes = socket(family, type, protocol);
+
+#if APR_HAVE_IPV6
+    if ((*new)->socketdes < 0 && ofamily == APR_UNSPEC) {
+        family = APR_INET;
+        (*new)->socketdes = socket(family, type, protocol);
+    }
+#endif
+
+    if ((*new)->socketdes < 0) {
+        return errno;
+    }
+    set_socket_vars(*new, family, type, protocol);
+
+    (*new)->timeout = -1;
+    (*new)->inherit = 0;
+    apr_pool_cleanup_register((*new)->cntxt, (void *)(*new), socket_cleanup,
+                              socket_cleanup);
+    return APR_SUCCESS;
+} 
+
+apr_status_t apr_socket_create(apr_socket_t **new, int family, int type,
+                               apr_pool_t *cont)
+{
+    return apr_socket_create_ex(new, family, type, 0, cont);
+}
+
+apr_status_t apr_socket_shutdown(apr_socket_t *thesocket, 
+                                 apr_shutdown_how_e how)
+{
+    return (shutdown(thesocket->socketdes, how) == -1) ? errno : APR_SUCCESS;
+}
+
+apr_status_t apr_socket_close(apr_socket_t *thesocket)
+{
+    return apr_pool_cleanup_run(thesocket->cntxt, thesocket, socket_cleanup);
+}
+
+apr_status_t apr_socket_bind(apr_socket_t *sock, apr_sockaddr_t *sa)
+{
+    if (bind(sock->socketdes, 
+             (struct sockaddr *)&sa->sa, sa->salen) == -1) {
+        return errno;
+    }
+    else {
+        sock->local_addr = sa;
+        /* XXX IPv6 - this assumes sin_port and sin6_port at same offset */
+        if (sock->local_addr->sa.sin.sin_port == 0) { /* no need for ntohs() when comparing w/ 0 */
+            sock->local_port_unknown = 1; /* kernel got us an ephemeral port */
+        }
+        return APR_SUCCESS;
+    }
+}
+
+apr_status_t apr_socket_listen(apr_socket_t *sock, apr_int32_t backlog)
+{
+    if (listen(sock->socketdes, backlog) == -1)
+        return errno;
+    else
+        return APR_SUCCESS;
+}
+
+apr_status_t apr_socket_accept(apr_socket_t **new, apr_socket_t *sock,
+                               apr_pool_t *connection_context)
+{
+    alloc_socket(new, connection_context);
+    set_socket_vars(*new, sock->local_addr->sa.sin.sin_family, SOCK_STREAM, sock->protocol);
+
+#ifndef HAVE_POLL
+    (*new)->connected = 1;
+#endif
+    (*new)->timeout = -1;
+    
+    (*new)->socketdes = accept(sock->socketdes, 
+                               (struct sockaddr *)&(*new)->remote_addr->sa,
+                               &(*new)->remote_addr->salen);
+
+    if ((*new)->socketdes < 0) {
+        return errno;
+    }
+#ifdef TPF
+    if ((*new)->socketdes == 0) { 
+        /* 0 is an invalid socket for TPF */
+        return APR_EINTR;
+    }
+#endif
+
+    *(*new)->local_addr = *sock->local_addr;
+
+    /* The above assignment just overwrote the pool entry. Setting the local_addr 
+       pool for the accepted socket back to what it should be.  Otherwise all 
+       allocations for this socket will come from a server pool that is not
+       freed until the process goes down.*/
+    (*new)->local_addr->pool = connection_context;
+
+    /* fix up any pointers which are no longer valid */
+    if (sock->local_addr->sa.sin.sin_family == AF_INET) {
+        (*new)->local_addr->ipaddr_ptr = &(*new)->local_addr->sa.sin.sin_addr;
+    }
+#if APR_HAVE_IPV6
+    else if (sock->local_addr->sa.sin.sin_family == AF_INET6) {
+        (*new)->local_addr->ipaddr_ptr = &(*new)->local_addr->sa.sin6.sin6_addr;
+    }
+#endif
+    (*new)->remote_addr->port = ntohs((*new)->remote_addr->sa.sin.sin_port);
+    if (sock->local_port_unknown) {
+        /* not likely for a listening socket, but theoretically possible :) */
+        (*new)->local_port_unknown = 1;
+    }
+
+#if APR_TCP_NODELAY_INHERITED
+    if (apr_is_option_set(sock->netmask, APR_TCP_NODELAY) == 1) {
+        apr_set_option(&(*new)->netmask, APR_TCP_NODELAY, 1);
+    }
+#endif /* TCP_NODELAY_INHERITED */
+#if APR_O_NONBLOCK_INHERITED
+    if (apr_is_option_set(sock->netmask, APR_SO_NONBLOCK) == 1) {
+        apr_set_option(&(*new)->netmask, APR_SO_NONBLOCK, 1);
+    }
+#endif /* APR_O_NONBLOCK_INHERITED */
+
+    if (sock->local_interface_unknown ||
+        !memcmp(sock->local_addr->ipaddr_ptr,
+                generic_inaddr_any,
+                sock->local_addr->ipaddr_len)) {
+        /* If the interface address inside the listening socket's local_addr wasn't 
+         * up-to-date, we don't know local interface of the connected socket either.
+         *
+         * If the listening socket was not bound to a specific interface, we
+         * don't know the local_addr of the connected socket.
+         */
+        (*new)->local_interface_unknown = 1;
+    }
+
+    (*new)->inherit = 0;
+    apr_pool_cleanup_register((*new)->cntxt, (void *)(*new), socket_cleanup,
+                              socket_cleanup);
+    return APR_SUCCESS;
+}
+
+apr_status_t apr_socket_connect(apr_socket_t *sock, apr_sockaddr_t *sa)
+{
+    int rc;        
+
+    do {
+        rc = connect(sock->socketdes,
+                     (const struct sockaddr *)&sa->sa.sin,
+                     sa->salen);
+    } while (rc == -1 && errno == EINTR);
+
+    /* we can see EINPROGRESS the first time connect is called on a non-blocking
+     * socket; if called again, we can see EALREADY
+     */
+    if (rc == -1 && (errno == EINPROGRESS || errno == EALREADY) &&
+        apr_is_option_set(sock->netmask, APR_SO_TIMEOUT)) {
+        rc = apr_wait_for_io_or_timeout(NULL, sock, 0);
+        if (rc != APR_SUCCESS) {
+            return rc;
+        }
+
+#ifdef SO_ERROR
+        {
+            int error;
+            apr_socklen_t len = sizeof(error);
+            if ((rc = getsockopt(sock->socketdes, SOL_SOCKET, SO_ERROR, 
+                                 (char *)&error, &len)) < 0) {
+                return errno;
+            }
+            if (error) {
+                return error;
+            }
+        }
+#endif /* SO_ERROR */
+    }
+
+    if (rc == -1 && errno != EISCONN) {
+        return errno;
+    }
+
+    sock->remote_addr = sa;
+    if (sock->local_addr->port == 0) {
+        /* connect() got us an ephemeral port */
+        sock->local_port_unknown = 1;
+    }
+    if (!memcmp(sock->local_addr->ipaddr_ptr,
+                generic_inaddr_any,
+                sock->local_addr->ipaddr_len)) {
+        /* not bound to specific local interface; connect() had to assign
+         * one for the socket
+         */
+        sock->local_interface_unknown = 1;
+    }
+#ifndef HAVE_POLL
+    sock->connected=1;
+#endif
+    return APR_SUCCESS;
+}
+
+apr_status_t apr_socket_data_get(void **data, const char *key, apr_socket_t *sock)
+{
+    sock_userdata_t *cur = sock->userdata;
+
+    *data = NULL;
+
+    while (cur) {
+        if (!strcmp(cur->key, key)) {
+            *data = cur->data;
+            break;
+        }
+        cur = cur->next;
+    }
+
+    return APR_SUCCESS;
+}
+
+apr_status_t apr_socket_data_set(apr_socket_t *sock, void *data, const char *key,
+                                 apr_status_t (*cleanup) (void *))
+{
+    sock_userdata_t *new = apr_palloc(sock->cntxt, sizeof(sock_userdata_t));
+
+    new->key = apr_pstrdup(sock->cntxt, key);
+    new->data = data;
+    new->next = sock->userdata;
+    sock->userdata = new;
+
+    if (cleanup) {
+        apr_pool_cleanup_register(sock->cntxt, data, cleanup, cleanup);
+    }
+
+    return APR_SUCCESS;
+}
+
+apr_status_t apr_os_sock_get(apr_os_sock_t *thesock, apr_socket_t *sock)
+{
+    *thesock = sock->socketdes;
+    return APR_SUCCESS;
+}
+
+apr_status_t apr_os_sock_make(apr_socket_t **apr_sock, 
+                              apr_os_sock_info_t *os_sock_info, 
+                              apr_pool_t *cont)
+{
+    alloc_socket(apr_sock, cont);
+#ifdef APR_ENABLE_FOR_1_0 /* no protocol field yet */
+    set_socket_vars(*apr_sock, os_sock_info->family, os_sock_info->type, os_sock_info->protocol);
+#else
+    set_socket_vars(*apr_sock, os_sock_info->family, os_sock_info->type, 0);
+#endif
+    (*apr_sock)->timeout = -1;
+    (*apr_sock)->socketdes = *os_sock_info->os_sock;
+    if (os_sock_info->local) {
+        memcpy(&(*apr_sock)->local_addr->sa.sin, 
+               os_sock_info->local, 
+               (*apr_sock)->local_addr->salen);
+        /* XXX IPv6 - this assumes sin_port and sin6_port at same offset */
+        (*apr_sock)->local_addr->port = ntohs((*apr_sock)->local_addr->sa.sin.sin_port);
+    }
+    else {
+        (*apr_sock)->local_port_unknown = (*apr_sock)->local_interface_unknown = 1;
+    }
+    if (os_sock_info->remote) {
+#ifndef HAVE_POLL
+        (*apr_sock)->connected = 1;
+#endif
+        memcpy(&(*apr_sock)->remote_addr->sa.sin, 
+               os_sock_info->remote,
+               (*apr_sock)->remote_addr->salen);
+        /* XXX IPv6 - this assumes sin_port and sin6_port at same offset */
+        (*apr_sock)->remote_addr->port = ntohs((*apr_sock)->remote_addr->sa.sin.sin_port);
+    }
+    else {
+        (*apr_sock)->remote_addr_unknown = 1;
+    }
+        
+    (*apr_sock)->inherit = 0;
+    apr_pool_cleanup_register((*apr_sock)->cntxt, (void *)(*apr_sock), 
+                              socket_cleanup, socket_cleanup);
+    return APR_SUCCESS;
+}
+
+apr_status_t apr_os_sock_put(apr_socket_t **sock, apr_os_sock_t *thesock, 
+                           apr_pool_t *cont)
+{
+    /* XXX Bogus assumption that *sock points at anything legit */
+    if ((*sock) == NULL) {
+        alloc_socket(sock, cont);
+        /* XXX IPv6 figure out the family here! */
+        /* XXX figure out the actual socket type here */
+        /* *or* just decide that apr_os_sock_put() has to be told the family and type */
+        set_socket_vars(*sock, APR_INET, SOCK_STREAM, 0);
+        (*sock)->timeout = -1;
+    }
+    (*sock)->local_port_unknown = (*sock)->local_interface_unknown = 1;
+    (*sock)->remote_addr_unknown = 1;
+    (*sock)->socketdes = *thesock;
+    return APR_SUCCESS;
+}
+
+APR_IMPLEMENT_INHERIT_SET(socket, inherit, cntxt, socket_cleanup)
+
+APR_IMPLEMENT_INHERIT_UNSET(socket, inherit, cntxt, socket_cleanup)
+
+/* deprecated */
+apr_status_t apr_shutdown(apr_socket_t *thesocket, apr_shutdown_how_e how)
+{
+    return apr_socket_shutdown(thesocket, how);
+}
+
+/* deprecated */
+apr_status_t apr_bind(apr_socket_t *sock, apr_sockaddr_t *sa)
+{
+    return apr_socket_bind(sock, sa);
+}
+
+/* deprecated */
+apr_status_t apr_listen(apr_socket_t *sock, apr_int32_t backlog)
+{
+    return apr_socket_listen(sock, backlog);
+}
+
+/* deprecated */
+apr_status_t apr_accept(apr_socket_t **new, apr_socket_t *sock,
+                        apr_pool_t *connection_context)
+{
+    return apr_socket_accept(new, sock, connection_context);
+}
+
+/* deprecated */
+apr_status_t apr_connect(apr_socket_t *sock, apr_sockaddr_t *sa)
+{
+    return apr_socket_connect(sock, sa);
+}
